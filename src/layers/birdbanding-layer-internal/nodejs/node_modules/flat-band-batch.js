'use strict';

//#############################
//    MODULES
//#############################
const Promise = require('bluebird');
const Util = require('util');
const uuidv4 = require('uuid/v4');
const Moment = require('moment');
const AJV = require('ajv');
const prompt = require('prompt');
const colors = require('colors');

// const json_schema_defs = require('../schemas/json_schema_defs');
// const Custom_Error = require('./custom-error').CustomError;

const BBSSHelpers = require('./bb-spreadsheet-helpers.js');
const Helpers = require('./helpers.js');
const BatchRecord = require('./record-batch.js');
const FlatBandIndividual = require('./flat-band-individual.js');

// const DBInterface = require('./banding-db-interface.js').BandingDBInterface;
// const Query = require('./banding-db-interface.js').Query;
// const BB_BusinessValidations = require('./banding-business-validation');

//#############################
//    DEFAULTS
//#############################

// Default constructor values
const defaults = {
  recordBatchId: null,
  creationTimestamp: null
}

//#############################
//   FLAT-BAND-BATCH FACTORY
//#############################
class FlatBandBatchFactory {

  constructor() {
    this.errors = [];
  }

  // TODO

}

//#############################
//    MAIN FLAT-BAND-BATCH CLASS
//#############################
class FlatBandBatch extends BatchRecord {

  // Constructor
  constructor(data) {
    //------------------------------------------------------    
    // Do base class construction first
    super(data);

    // Set default values
    this.metadata.recordBatchId = uuidv4();
    this.metadata.creationTimestamp = Moment().toDate().toISOString();
  }

  // Getters & Setters
  // Refer to Abstract superclass

  //****************************
  //   Band Batch Methods
  //****************************
  populateFromSpreadsheet(sheetJson, spreadsheetMapping, gamebird = false, ssFile = 'unknown') {
    // ----------------------------------------------------------------------------
    return new Promise((resolve, reject) => {

      console.info("BandBatch.populateFromSpreadsheet()");

      // This method intended to populate an object representing a batch of band records
      // from JSON generated directly from a supported birdbanding spreadsheet object.

      // Note -> validation of the spreadsheet format (based on column headers)
      //         should have taken place before this point. Any validation after
      //         this point should be related to validating the ACTUAL band records
      //         themselves.

      if (!sheetJson || !sheetJson.rows) { return reject(new Error("Insufficient Spreadsheet data!")); }

      var promises = [];
      var mapping = spreadsheetMapping;
      this.errors = [];
      this.records = [];

      console.info("Populating from spreadsheet containing " + sheetJson.rows.length +  " row(s)");

      // Iterate over all the rows in the passed worksheet creating band records as appropriate.
      // This is the row INDEX not the excel row NUMBER. Actual data starts on row 2 which is index 0.
      for (var rowIndex = 0; rowIndex < sheetJson.rows.length; rowIndex++) {

        // Grab a working copy
        let row = sheetJson.rows[rowIndex];

        // Skip Empty Rows
        if (!Object.values(row).some(x => (x !== null && x !== undefined && x !== '' && String(x).trim() !== ''))){
          console.warn("Spreadsheet row " + (rowIndex+2) + " appears to be empty. Skipping...");
          continue;
        }

        // Skip Rows with instructional text
        if (row.hasOwnProperty('NZNBBS_Code') && row['NZNBBS_Code'] &&
          String(row['NZNBBS_Code']).toLowerCase().includes('drag all data validation')){        
          console.warn("Spreadsheet row " + (rowIndex+2) + " Includes instructional text. Skipping...");
          continue;
        }

        // Row is legit

        // First check whether this row data should be used to generate two records.
        // One row is split into two based on certain criteria. Note, the row index
        // for any resulting split rows is the same as the parent, hence it's possible
        // to have two records with the same rowNum.
        let rows = BBSSHelpers.SplitRows(row, mapping);

        // After splitting, we now have a 1:1 relationship between rows and records.
        // Iterate over the spreadsheet rows, generating a new banding record for each
        // and populating as appropriate.
        rows.forEach(row => {
          let bandRecord = new FlatBandIndividual.FlatBandIndividual(ssFile, (rowIndex+2), gamebird);
          promises.push(bandRecord.populateFromSpreadsheet(row, mapping, gamebird));          
        });
      }

      Promise.all(promises)
        .then(res => {
          this.records = Helpers.flattenArray(res);
          return resolve(this);
        });
    });
  }

  saveToDB(json) { 
    // ---------------------------------------------------------------------------- 
      return new Promise((resolve, reject) => { 
   
        console.info("BandBatch.saveToDB()"); 
   
        // Try throwing all the rows into the DB
        rows.forEach(row => {
          promises.push(bandRecord.populateFromSpreadsheet(row, mapping, gamebird));          
        });

        // Get the connection to the database and pass it through.       
        return getDBConnection()
        .then(db => {
  
          // Determine the record type and save appropriate records
          // To the Database
          switch(this.nznbbsCode){
            
            // First Capture Event
            case '1':
              resolve();
  
            default:
              this.captureCode = "0";   
          }
        }); 
      }); 
    } 

  // populateBatchDBRec(overwrite = [], scriptArgs) {
  //   // ----------------------------------------------------------------------------
  //   return new Promise((resolve, reject) => {

  //     console.info("BandBatch.populateBatchDBRec()");
  //     // This method intended to populate a child DB record object related to a batch of band records
  //     //  -> This record will be used to populate a PDB band record with any supplementary information, and,
  //     //  -> This DB record will also be used to validate the batch record during the next step of the process

  //     // Construct query list based on the bandrecords populated to date
  //     var queryList = [];

  //     // (1) For the batch of band numbers, setup a query to check whether any of these are already in the database (in which case we want to use the existing birdId)
  //     var input = {
  //       bandNumbers: this.records.map((record) => {
  //         return {
  //           'bandPrefixNumber': record.bandPrefixNumber,
  //           'bandShortNumber': record.bandShortNumber
  //         }
  //       })
  //     }
  //     queryList.push(new Query('SP_GetBirdCurrentSummaries', input, 'list'));

  //     // (2) For the batch of band numbers, we are also interested in validating the species associated with each record (if it's a record related to a bird)
  //     var input = {
  //       species: this.records.map((record) => {
  //         if (record.bird.scientificName && record.bird.speciesCode) {
  //           return {
  //             'scientificName': record.bird.scientificName,
  //             'speciesCode': record.bird.speciesCode
  //           }
  //         }
  //       })
  //     }
  //     queryList.push(new Query('SP_GetNZNBBSSpeciesSubset', input, 'list'));

  //     // (2a) If the spreadsheet version is simple, also query the species list based solely on the species code
  //     if (scriptArgs.ss_version === 'simple') {
  //       var input = {
  //         species: this.records.map((record) => {
  //           if (record.bird.speciesCode) {
  //             return {
  //               'speciesCode': record.bird.speciesCode
  //             }
  //           }
  //         })
  //       }
  //     }
  //     queryList.push(new Query('SP_GetNZNBBSSpeciesSubsetbySpeciesCode', input, 'list'));

  //     // (3) For the batch of band numbers, we are also interested in validating the people associated with each record (particular those requiring certification)
  //     var input = {
  //       people: []
  //     };
  //     input.people = this.records.reduce((accumulator, current_record) => {
  //       if (current_record.person.l3.number) {
  //         accumulator.push({
  //           'certificationNumber': current_record.person.l3.number
  //         });
  //       }
  //       if (current_record.person.bander.number) {
  //         accumulator.push({
  //           'certificationNumber': current_record.person.bander.number
  //         });
  //       }
  //       return accumulator;
  //     }, []);
  //     queryList.push(new Query('SP_GetCertifiedBandersSubset', input, 'list'));

  //     // (4) For the batch of band numbers, we are also interested in check whether there is a chance any of the records have already been uploaded to the database
  //     //      -> there is a risk of encountering duplicate data when dealing with our disparate data sources
  //     var input = {
  //       records: this.records
  //     }
  //     queryList.push(new Query('SP_CheckDuplicateBandRecords', input, 'list'));

  //     // (5) For the batch of band numbers, setup a query to check which of these records have associated 'band issue' records in the database
  //     var input = {
  //       bandNumbers: this.records.map((record) => {
  //         return {
  //           'bandPrefixNumber': record.bandPrefixNumber,
  //           'bandShortNumber': record.bandShortNumber
  //         }
  //       })
  //     }
  //     queryList.push(new Query('SP_CheckBandsIssued', input, 'list'));

  //     // (6) For the batch of band numbers, we are also interested in validating the band sizes against the associated species which has been recorded
  //     var input = {
  //       species: this.records.map((record) => {
  //         if (record.bird.scientificName && record.bird.speciesCode) {
  //           return {
  //             'scientificName': record.bird.scientificName,
  //             'speciesCode': record.bird.speciesCode
  //           }
  //         }
  //       })
  //     }
  //     queryList.push(new Query('SP_GetAllowableBandSizes', input, 'list'));

  //     // (6a) For the batch of band numbers in a simple version of the spreadsheet, need to query the allowable band sizes by species code only
  //     var input = {
  //       species: this.records.map((record) => {
  //         if (record.bird.speciesCode) {
  //           return {
  //             'speciesCode': record.bird.speciesCode
  //           }
  //         }
  //       })
  //     }
  //     queryList.push(new Query('SP_GetAllowableBandSizesBySpeciesCode', input, 'list'));

  //     // (7) For the batch of band numbers, setup a query to check that any proposed changes to the chronology structure is valid
  //     var input = {
  //       bandNumbers: this.records.map((record) => {
  //         return {
  //           'bandPrefixNumber': record.bandPrefixNumber,
  //           'bandShortNumber': record.bandShortNumber
  //         }
  //       })
  //     }
  //     queryList.push(new Query('SP_CheckBandOnBirdChronology', input, 'list'));


  //     // (8) Query the historic banders list to ensure we are minimising the risk of adding any duplicates to the database
  //     input = {};
  //     queryList.push(new Query('SP_GetHistoricBanders', input, 'list'));

  //     // (9) For the batch of band numbers, setup a query to check that any proposed changes to the inventory chronology structure are valid
  //     var input = {
  //       bandNumbers: this.records.map((record) => {
  //         return {
  //           'bandPrefixNumber': record.bandPrefixNumber,
  //           'bandShortNumber': record.bandShortNumber
  //         }
  //       })
  //     }
  //     queryList.push(new Query('SP_CheckBandInventoryChronology', input, 'list'));

  //     // Create a new DBRecord to allow us to pull information to:
  //     // (a) Populate supplementary band information (e.g. birdId)
  //     // (b) Use later during validation of business logic
  //     this.dbRecord = new DBInterface(scriptArgs.env);
  //     this.dbRecord.getConnectionDetails()
  //       .then((dbConfig) => {
  //         return resolve(this.dbRecord.queryWrapper(dbConfig, queryList));
  //       })
  //       .catch(error => {
  //         console.error(error);
  //       });
  //   });
  // }

  // populateSupplementaryDBData(ss_version) {
  //   // ----------------------------------------------------------------------------
  //   return new Promise((resolve, reject) => {

  //     console.info("BandBatch.populateSupplementaryDBData()");
  //     console.info('[band number] : [bird id]');

  //     this.records.reduce((accumulator, current_record) => {
  //       // ONLY NEED TO ASSIGN A BIRD-ID if this is a bird record!
  //       if (['c', 'z', '1', '2', '2a', '2b', '2c', '2d', '3', '4', 'x'].includes(current_record.nznbbsCode)) {
  //         // Step (1) Check if DB Record has found the band associated with a given record
  //         //        -> If so, assign the corresponding bird id to this record,
  //         this.dbRecord.data.birdCurrentSummaries.map(birdSummary => {
  //           if (birdSummary.BandPrefixNumber === current_record.bandPrefixNumber && birdSummary.BandShortNumber === current_record.bandShortNumber) {
  //             current_record.bird.birdId = birdSummary.BirdId;
  //             console.info(`${current_record.bandPrefixNumber}-${current_record.bandShortNumber} : ${current_record.bird.birdId}`);
  //           }
  //         });

  //         if (!current_record.bird.birdId) {
  //           // Step (2)
  //           //        -> If no Bird Id found in DB, check whether this bird has already been given a new birdId (check .reduce()'s accumulator ONLY))
  //           //        -> Static copy of our birdId accumulator array required to prevent infinite map => push cycle!
  //           accumulator.map(accumulatedRecord => {
  //             if (accumulatedRecord.bandPrefixNumber === current_record.bandPrefixNumber && accumulatedRecord.bandShortNumber === current_record.bandShortNumber) {
  //               current_record.bird.birdId = accumulatedRecord.bird.birdId;
  //               console.info(`${current_record.bandPrefixNumber}-${current_record.bandShortNumber} : ${current_record.bird.birdId}`);
  //             }
  //           });

  //           if (!current_record.bird.birdId) {
  //             // Step (3)
  //             //        -> If still no Bird Id, this record will need a new Bird Id assigned to it (a UUID for now :) )
  //             current_record.bird.birdId = uuidv4();
  //             console.info(`${current_record.bandPrefixNumber}-${current_record.bandShortNumber} : ${current_record.bird.birdId}`);
  //             // Only accumulate birds which are new in this batch of records
  //             accumulator.push(current_record);
  //           }
  //         }
  //       }
  //       return accumulator;
  //     }, []);

  //     // If the spreadsheet is the simple version - add the species details based on the species code
  //     if (ss_version === 'simple') {
  //       this.records.forEach(record => {
  //         var speciesLookup = this.dbRecord.data.nZNBBSSpeciesSubsetbySpeciesCode.find((species) => {
  //           return (record.bird.speciesCode === species.SpeciesCodeNZNBBS.toLowerCase());
  //         });
  //         record.bird.scientificName = speciesLookup.ScientificNameNZNBBS.toLowerCase();
  //         record.bird.commonName = speciesLookup.CommonNameNZNBBS.toLowerCase();
  //       });
  //     }
  //     return resolve(this);
  //   });
  // }

  // validateSchema() {
  //   // ----------------------------------------------------------------------------
  //   return new Promise((resolve, reject) => {

  //     console.info("BandBatch.validateSchema()");

  //     var ajv = new AJV({
  //       verbose: true,
  //       allErrors: true,
  //       jsonPointers: true
  //     });
  //     var validate = ajv.addSchema(json_schema_defs.birdSubObjectSchema)
  //       .addSchema(json_schema_defs.personSubObjectSchema)
  //       .addSchema(json_schema_defs.locationSubObjectSchema)
  //       .addSchema(json_schema_defs.bandsSubObjectSchema)
  //       .addSchema(json_schema_defs.individualBirdRecordObjectSchema)
  //       .compile(json_schema_defs.batchBirdRecordObjectSchema);
  //     var valid = validate(this.data, {});

  //     if (validate.errors) {
  //       // The schema validation process has picked up errors
  //       // -> Handle accordingly for user review
  //       var custom_errors = validate.errors.map(error => {
  //         var recordId = error.dataPath.match(/\/records\/([0-9]+)/)[1];
  //         var ssRowNum = 'spreadsheet row ' + (this.records[recordId].ssRowNum);
  //         var jsonPointerSplit = error.dataPath.split('/');
  //         // Extract the spreadsheet property name (which can be nested up to 4 properties deep)
  //         var ssProperty = (jsonPointerSplit.indexOf(recordId) + 4 < jsonPointerSplit.length) ?
  //           jsonPointerSplit[jsonPointerSplit.indexOf(recordId) + 1] + '][' + jsonPointerSplit[jsonPointerSplit.indexOf(recordId) + 2] + '][' + jsonPointerSplit[jsonPointerSplit.indexOf(recordId) + 3] + '][' + jsonPointerSplit[jsonPointerSplit.indexOf(recordId) + 4] :
  //           (((jsonPointerSplit.indexOf(recordId) + 3) < jsonPointerSplit.length) ?
  //             jsonPointerSplit[jsonPointerSplit.indexOf(recordId) + 1] + '][' + jsonPointerSplit[jsonPointerSplit.indexOf(recordId) + 2] + '][' + jsonPointerSplit[jsonPointerSplit.indexOf(recordId) + 3] :
  //             (((jsonPointerSplit.indexOf(recordId) + 2) < jsonPointerSplit.length) ?
  //               jsonPointerSplit[jsonPointerSplit.indexOf(recordId) + 1] + '][' + jsonPointerSplit[jsonPointerSplit.indexOf(recordId) + 2] :
  //               jsonPointerSplit[jsonPointerSplit.indexOf(recordId) + 1]));
  //         var ssFile = this.records[recordId].ssFilename;
  //         return new Custom_Error('schema', error.keyword, [error.dataPath.match(/^\[object Object\](.*)$/)[1], error.data, JSON.stringify(error.schema), ssRowNum, ssProperty, ssFile, this.records[recordId].ssRowNum, this.records[recordId].bandRecordId]);
  //       });

  //       this.errors.push.apply(this.errors, custom_errors);
  //     }

  //     return resolve(this.errors);
  //   });
  // }

  // sortRecordsChronologically() {
  //   // ----------------------------------------------------------------------------
  //   return new Promise((resolve, reject) => {

  //     console.info("BandBatch.sortRecordsChronologically()");

  //     this.records = this.records.sort((a, b) => {
  //       if (Moment(a.recordTimestamp) < Moment(b.recordTimestamp)) {
  //         return -1;
  //       }
  //       else if (Moment(a.recordTimestamp) > Moment(b.recordTimestamp)) {
  //         return 1;
  //       }
  //       else {
  //         return 0;
  //       }
  //     });

  //     return resolve();
  //   });
  // }

  // validateBusinessRules(scriptArgs) {
  //   // ----------------------------------------------------------------------------
  //   return new Promise((resolve, reject) => {

  //     console.info("BandBatch.validateBusinessRules()");

  //     // TODO
  //     if (!this.dbRecord) {
  //       throw new Error('This batch record does not have an associated DB record yet! Cannot complete birdbanding business rule validations');
  //     } else {
  //       BB_BusinessValidations.getProposeHistoricBandersList(this, scriptArgs)
  //         .then(historicBanders => {
  //           var promises = [];

  //           // Check if the --hb [next-historic-bander-number] override has been used and if so, prior to validating certified banders, add any non-certified banders to the 
  //           if (historicBanders.length > 0 && scriptArgs.validation_override_historic_bander) {
  //             // Historic banders override enacted!
  //             // -> ADD HISTORIC BANDERS before continuing
  //             var queryList = [];
  //             var input = {
  //               historicBanders: historicBanders
  //             };
  //             queryList.push(new Query('SP_InsertHistoricBanders', input, 'list'));

  //             this.dbRecord.getConnectionDetails()
  //               .then((dbConfig) => {
  //                 return this.dbRecord.queryWrapper(dbConfig, queryList);
  //               })
  //               .catch(error => {
  //                 console.error(error);
  //               })
  //               .then(() => {
  //                 // (1) The minimum amount of data required for the NZNBBS Code must be provided
  //                 promises.push(BB_BusinessValidations.nznbbsCodeFieldValidation(this));

  //                 // (2) The band number provided must match the allowable values for the chosen species
  //                 if (!scriptArgs.validation_override_band_prefix) {
  //                   promises.push(BB_BusinessValidations.bandPrefixValidation(this, scriptArgs.ss_version));
  //                 }

  //                 // (3) The scientific name, common name and species code must be compatible with eachother and all must be within the NZNBBS set
  //                 promises.push(BB_BusinessValidations.birdClassificationValidation(this, scriptArgs.ss_version));

  //                 // (4) The L3 or Bander associated with a band record must have a banding number within the NZNBBS registered banders set OR be a historic bander
  //                 if (!scriptArgs.validation_override_bander_certification) {
  //                   promises.push(BB_BusinessValidations.certifiedBanderValidation(this));
  //                 }

  //                 // (5) The bandPrefixNumber and bandShortNumber must match a band issued within the inventory register (except if NZNBBS code is Z)
  //                 if (!scriptArgs.validation_override_inventory_check) {
  //                   promises.push(BB_BusinessValidations.bandInventoryValidation(this));
  //                 }

  //                 // (6) The record object itself must not duplicate any records already stored within the database (or be a repeat record within the submitted batch of records)
  //                 promises.push(BB_BusinessValidations.duplicateRecordValidation(this));

  //                 // (7a) All band-on-bird markings/recoveries must follow a valid chronology (ss), and, 
  //                 // (9a) Records must follow a valid chronology with respect to inventory band records (ss)
  //                 promises.push(BB_BusinessValidations.bandChronologySSValidation(this));

  //                 // (7b) All band-on-bird markings/recoveries must follow a valid chronology (db)
  //                 promises.push(BB_BusinessValidations.bandChronologyDBValidation(this));

  //                 // (8) The species details for a bird with a specific birdId must be consistent (i.e. not change with bird chronology)
  //                 promises.push(BB_BusinessValidations.birdEntitySpeciesValidation(this));

  //                 // (9b) Records must follow a valid chronology with respect to inventory band records (db)
  //                 promises.push(BB_BusinessValidations.bandInventoryChronologyDBValidation(this));

  //                 Promise.all(promises)
  //                   .then(res => {
  //                     this.errors = Helpers.flattenArray(res);
  //                     return resolve(this.errors);
  //                   });
  //               });
  //           } else {
  //             // SKIP the historic banders addition

  //             // (1) The minimum amount of data required for the NZNBBS Code must be provided
  //             promises.push(BB_BusinessValidations.nznbbsCodeFieldValidation(this));

  //             // (2) The band number provided must match the allowable values for the chosen species
  //             if (!scriptArgs.validation_override_band_prefix) {
  //               promises.push(BB_BusinessValidations.bandPrefixValidation(this, scriptArgs.ss_version));
  //             }

  //             // (3) The scientific name, common name and species code must be compatible with eachother and all must be within the NZNBBS set
  //             promises.push(BB_BusinessValidations.birdClassificationValidation(this, scriptArgs.ss_version));

  //             // (4) The L3 or Bander associated with a band record must have a banding number within the NZNBBS registered banders set OR be a historic bander
  //             if (!scriptArgs.validation_override_bander_certification) {
  //               promises.push(BB_BusinessValidations.certifiedBanderValidation(this));
  //             }

  //             // (5) The bandPrefixNumber and bandShortNumber must match a band issued within the inventory register (except if NZNBBS code is Z)
  //             if (!scriptArgs.validation_override_inventory_check) {
  //               promises.push(BB_BusinessValidations.bandInventoryValidation(this));
  //             }

  //             // (6) The record object itself must not duplicate any records already stored within the database (or be a repeat record within the submitted batch of records)
  //             promises.push(BB_BusinessValidations.duplicateRecordValidation(this));

  //             // (7a) All band-on-bird markings/recoveries must follow a valid chronology (ss), and, 
  //             // (9a) Records must follow a valid chronology with respect to inventory band records (ss)
  //             promises.push(BB_BusinessValidations.bandChronologySSValidation(this));

  //             // (7b) All band-on-bird markings/recoveries must follow a valid chronology (db)
  //             promises.push(BB_BusinessValidations.bandChronologyDBValidation(this));

  //             // (8) The species details for a bird with a specific birdId must be consistent (i.e. not change with bird chronology)
  //             promises.push(BB_BusinessValidations.birdEntitySpeciesValidation(this));

  //             // (9b) Records must follow a valid chronology with respect to inventory band records (db)
  //             promises.push(BB_BusinessValidations.bandInventoryChronologyDBValidation(this));

  //             Promise.all(promises)
  //               .then(res => {
  //                 this.errors = Helpers.flattenArray(res);
  //                 return resolve(this.errors);
  //               });
  //           }
  //         });
  //     }
  //   });
  // }

  // userConfirmDBUpload() {
  //   // ----------------------------------------------------------------------------
  //   return new Promise((resolve, reject) => {

  //     console.info("BandBatch.userConfirmDBUpload()");

  //     // Start the prompt (using the prompt library: https://www.npmjs.com/package/prompt)

  //     prompt.message = '';
  //     var prompt_schema = {
  //       properties: {
  //         uploadResultsToDB: {
  //           description: colors.green('[INFO] Schema validation and business rules successfully validated for some records\n[PROMPT] Confirm upload of valid records to flat table?   ( Yes or No )'),
  //           type: 'string',
  //           pattern: /^(Yes|yes|No|no|y|n|Y|N)$/,
  //           message: colors.red('[HELP] Requires yes|y or no|n response'),
  //           required: true
  //         }
  //       }
  //     }

  //     prompt.start();

  //     prompt.get(prompt_schema, (err, result) => {
  //       if (['Yes', 'yes', 'Y', 'y'].includes(result.uploadResultsToDB)) {
  //         return resolve('yes');
  //       }
  //       else if (['No', 'no', 'N', 'n'].includes(result.uploadResultsToDB)) {
  //         return resolve('no');
  //       }
  //       else {
  //         throw new Error('Could not recognise user input -> please contact a developer to review')
  //       }
  //     });
  //   });
  // }

  // pruneErrorRecords() {
  //   // ----------------------------------------------------------------------------
  //   return new Promise((resolve, reject) => {

  //     console.info("BandBatch.pruneErrorRecords()");

  //     // Filter band records to be only those which do not have any associated errors
  //     this.records = this.records.filter(record => {
  //       return !this.errors.some(error => {
  //         return error.band_record_id === record.bandRecordId;
  //       })
  //     });
  //   });
  // }

  // uploadToDB() {
  //   // ----------------------------------------------------------------------------
  //   return new Promise((resolve, reject) => {

  //     console.info("BandBatch.uploadToDB()");

  //     var queryList = [];
  //     var input = {
  //       bandBatchRecord: this
  //     };
  //     queryList.push(new Query('SP_InsertBandBatchRecords', input, 'list'));

  //     this.dbRecord.getConnectionDetails()
  //       .then((dbConfig) => {
  //         return this.dbRecord.queryWrapper(dbConfig, queryList);
  //       })
  //       .catch(error => {
  //         console.error(error);
  //       })

  //     return resolve();

  //   });
  // }

  // flop() {
  //   // ----------------------------------------------------------------------------
  //   return new Promise((resolve, reject) => {

  //     console.info("FlatBandBatch.flop()");

  //     var records = [];
  //     this.records.forEach(record => {
  //       record.flop()
  //         .then(res => {
  //           records.push(res);
  //         });
  //     })
  //     return resolve({
  //       metadata: {
  //         recordBatchId: this.metadata.recordBatchId,
  //         creationTimestamp: this.metadata.creationTimestamp
  //       },
  //       records: records,
  //       errors: this.errors
  //     });
  //   });
  // }
}

//#############################
//    EXPORTS
//#############################
module.exports = {
  FlatBandBatch: FlatBandBatch,
  FlatBandBatchFactory: FlatBandBatchFactory
}