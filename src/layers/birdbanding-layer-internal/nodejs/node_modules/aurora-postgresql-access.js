'use strict'; 
 
//############################# 
//    MODULES 
//############################# 
const Promise = require('bluebird');
var AWSXRay = require('aws-xray-sdk');
var AWS = AWSXRay.captureAWS(require('aws-sdk'));
AWS.config.setPromisesDependency(require('bluebird'));
const massive = require('massive');
const Moment = require('moment'); 
 
//#####################################
//           MAIN METHODS
//#####################################
const getDBConnection = (db, dbCreationTimestamp) => {
  // ---------------------------------------------------------------------------- 
  // DB connection (container reuse of existing connection if available)
  // To account for container persistence of over 1hour, we need to check whether the connection has existed for over 20 minutes
  // If so, a refresh of the connection is required
  if (typeof db !== "undefined" && dbCreationTimestamp !== 'undefined' && !(Moment().diff(dbCreationTimestamp, 'seconds') > 890)){
    console.info(Moment().diff(dbCreationTimestamp, 'seconds') + ' seconds since connection established - reusing existing connection up until 890 seconds have passed...')
    return Promise.resolve({
      db,
      dbCreationTimestamp
    });
  }

  // If the connection exists but we want to refresh, close the existing pool
  if (typeof db !== "undefined") {
    db.instance.$pool.end();
  }

  // Get the database connection credentials
  // Note, our Aurora Cluster is configured for IAM Authorisation, rather
  // than per-user authorisation. This gives us some flexibility, but
  // means we've got to sign our access attempts with the appropriate 
  // sigv4 method. An Authorisation token is required instead of a password.
  var signer = new AWS.RDS.Signer({
    // Configure options. These are mostly passed in as environment variables.
    region: process.env.DATASTORE_REGION ? process.env.DATASTORE_REGION : process.env.AWS_REGION,
    username: process.env.DATASTORE_USERNAME,
    hostname: process.env.DATASTORE_ENDPOINT,
    port: parseInt(process.env.DATASTORE_PORT)
  });

  // These options are merged with those defined when creating the signer,
  // overriding in the case of a duplicate option credentials are not specified
  // here or when creating the signer, so default credential provider will be used 
  // Appears as though this should expire after 15 minutes based on these docs:
  // https://aws.amazon.com/premiumsupport/knowledge-center/users-connect-rds-iam/
  // However performance seems to suggest about 20 minutes
  // Stick with 15 mins for now but keep an eye on this if PAM issues result when 
  // connecting to the database cluster
  var token = signer.getAuthToken({})

  // console.info('Got Token: ' + token); 

  // Create the database connection here and return the DB instance
  // Note that Massive attempts to parse the entire DB and surface
  // a lovely API for you to use. This will take time for a big ol'
  // database, so we pass parameters to limit this to surface only
  // the objects we care about. This should reduce startup time.
  // All *_LIST variables should be a comma-separated string

  // THIS RETURNS A PROMISE
  console.info('Creating new connection. No existing database connection or connection over 890 seconds old...')
  return massive(
    {
      host: process.env.DATASTORE_ENDPOINT,
      port: parseInt(process.env.DATASTORE_PORT),
      database: process.env.DATASTORE_DBNAME,
      user: process.env.DATASTORE_USERNAME,
      password: token,
      ssl: {
        rejectUnauthorized: false
      },
      poolSize: 10
    },
    {
      allowedSchemas: process.env.DATASTORE_SCHEMA_WHITELIST,
      whitelist: process.env.DATASTORE_TABLEVIEW_WHITELIST,
      functionWhitelist: process.env.DATASTORE_FUNCTION_WHITELIST.split(',')
    },
    {
      promiseLib: Promise
    }
  )
  .then(dbCreated => {
    return {
      db: dbCreated,
      dbCreationTimestamp: Moment()
    }
  })
};
 
module.exports = {
  getDBConnection: getDBConnection
}
