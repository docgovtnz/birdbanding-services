'use strict';

// TODO MIGRATION TO LAMBDA LAYER ONCE FUNCTIONALITY STABLE
// KEPT HEAR FOR SIMPLE DEVELOPMENT
// COPY LATEST VERSION BETWEEN API AND API2 FOLDERS

// Modules
const Promise = require('bluebird');
const Util = require('util');
const _ = require('lodash')
const Moment = require('moment');
const MomentTimezone = require('moment-timezone');
const DBAccess = require('aurora-postgresql-access.js');
const BoilerPlate = require('api-boilerplate.js');
const BBSSHelpers = require('bb-spreadsheet-helpers');
const BBHelpers = require('bb-helpers');
const BBBusinessValidationAndErrors = require('bb-business-validation-and-errors');
const CustomErrorFactory = BBBusinessValidationAndErrors.CustomErrorFactory;
const Helpers = require('helpers.js');

const REQUIRED_PAYLOAD_PROPERTIES = ["event", "event_media", "bird", "characteristic_measurement", "mark_configuration_capture", "mark_configuration_release"];

const ALLOWABLE_STATUS_CODES = ["ALIVE", "DEAD_NOT_RECENT", "DEAD_RECENT", "DEAD_UNSPECIFIED", "UNKNOWN", "UNKNOWN_BAND_ONLY"];
const ALLOWABLE_CONDITION_CODES = ["GOOD", "POOR", "INJURED_SICK", "REHABILITATED", "ARTIFICIALLY_REARED", "OTHER"];


const validateUploadAccess = (customErrorFactory, db, projectId, claims, governingCognitoGroup) => {
  // ---------------------------------------------------------------------------- 
  console.info("validateUploadAccess()");

  var errors = [];

  // The Authorisation logic is fairly complex, and contained 
  // almost entirely in the database, therefore a complex stored
  // procedure does the work for us. Alternatively, we could make multiple
  // calls to the DB, get all the data we need, then perform the logic
  // here. That'd be more straightforward (and flexible), but also less
  // optimal.

  if (governingCognitoGroup === BBHelpers.ADMIN_GROUP_NAME) {
    return [];
  }

  return db.ro_is_authorised_for_upload(claims.sub, projectId)
    .then(auth => {

      // TEMPORARY / TESTING
      console.log(JSON.stringify(auth[0]));

      // If we returned nothing, or an empty array, or the returned value is FALSE, we're not authorized.
      if (!auth || auth.length <= 0 || !auth[0].ro_is_authorised_for_upload) {
        errors.push(customErrorFactory.getError('ProjectAuthorisationError', [projectId, 'pathParameters.projectId']));
      }

      // All good
      console.log(`Found ${errors.length} metadata validation error(s).`);
      return errors;
    });
};

const validateUpdateAccess = (customErrorFactory, db, event, projectId, claims, governingCognitoGroup) => {
  // ---------------------------------------------------------------------------- 
  console.info("validateUpdateAsssccess()");

  var errors = [];

  // The Authorisation logic is fairly complex, and contained 
  // almost entirely in the database, therefore a complex stored
  // procedure does the work for us. Alternatively, we could make multiple
  // calls to the DB, get all the data we need, then perform the logic
  // here. That'd be more straightforward (and flexible), but also less
  // optimal.

  if (governingCognitoGroup === BBHelpers.ADMIN_GROUP_NAME) {
    return [];
  }

  return db.ro_is_authorised_for_update(event.pathParameters.eventId, claims.sub, projectId)
    .then(auth => {

      // TEMPORARY / TESTING
      console.log(JSON.stringify(auth[0]));

      // If we returned nothing, or an empty array, or the returned value is FALSE, we're not authorized.
      if (!auth || auth.length <= 0 || !auth[0].ro_is_authorised_for_update) {
        errors.push(customErrorFactory.getError('UpdateAuthorisationError', [event.pathParameters.eventId, 'pathParameters.eventId']));
      }

      // All good
      console.log(`Found ${errors.length} metadata validation error(s).`);
      return errors;
    });
};


const validateGetAccess = async (customErrorFactory, db, event, claims, governingCognitoGroup) => {
  // ---------------------------------------------------------------------------- 
  console.info("validateGetAccess()");

  // The Authorisation logic is fairly complex, we call a number of functions to capture each component
  //   of the process
  let eventId = event.pathParameters.eventId;

  if (governingCognitoGroup === BBHelpers.ADMIN_GROUP_NAME) {
    return null;
  }

  let isRecordFromUserProjectResultSet = await db.ro_is_event_from_user_project(eventId, claims.sub);

  let isRecordSubmittedByUserResultSet = await db.ro_is_event_contributor(eventId, claims.sub);

  let isRecordPubliclyAvailableResultSet = await db.ro_is_event_project_public(eventId);

  let isUserBirdContributorResultSet = await db.ro_is_bird_contributor(eventId, claims.sub);

  console.log(isRecordFromUserProjectResultSet);
  console.log(isRecordSubmittedByUserResultSet);
  console.log(isRecordPubliclyAvailableResultSet);
  console.log(isUserBirdContributorResultSet);

  if (!isRecordFromUserProjectResultSet[0].ro_is_event_from_user_project
    && !isRecordSubmittedByUserResultSet[0].ro_is_event_contributor
    && !isRecordPubliclyAvailableResultSet[0].ro_is_event_project_public
    && !isUserBirdContributorResultSet[0].ro_is_bird_contributor) {
    return customErrorFactory.getError('ForbiddenError', [`accessing event: /view-data/event/${eventId}`, claims.sub, 'claims.sub']);
  }
  else {
    console.log('No errors');
    return null;
  }
};


const validateDeleteAccess = (customErrorFactory, db, event, claims, governingCognitoGroup) => {
  // ---------------------------------------------------------------------------- 
  console.info("validateDeleteAccess()");

  var errors = [];

  let eventId = event.pathParameters.eventId;

  if (governingCognitoGroup === BBHelpers.ADMIN_GROUP_NAME) {
    return errors;
  }

  return db.ro_is_authorised_for_deletion(claims.sub, eventId)
    .then(auth => {

      // TEMPORARY / TESTING
      console.log(JSON.stringify(auth[0]));

      // If we returned nothing, or an empty array, or the returned value is FALSE, we're not authorized.
      if (!auth || auth.length <= 0 || !auth[0].ro_is_authorised_for_deletion) {
        errors.push(customErrorFactory.getError('DeleteAuthorisationError', [eventId, claims.sub, 'claims.sub', 'User must be the bander (event_reporter), L3 (event_provider) or project manager (event_owner)']));
      }

      // All good
      console.log(`Found ${errors.length} metadata validation error(s).`);
      return errors;
    });
};


const validateEventExists = async (customErrorFactory, db, event, claims) => {
  // -----------------------------------------
  console.info(".validateEventExists()");

  let eventId = event.pathParameters.eventId;

  let eventExistsResultset = await db.ro_is_event(eventId);

  console.log(eventExistsResultset);
  if (!eventExistsResultset[0].ro_is_event) {
    return customErrorFactory.getError('NotFoundError', ['eventId', eventId, 'pathParameters.eventId']);
  }
  else {
    console.log('No errors');
    return null;
  }
}


const validatePayloadStructure = (payload) => {
  // ------------------------------------------
  let missingProps = REQUIRED_PAYLOAD_PROPERTIES.filter(prop => {
    return payload.reduce((accumulator, current) => {
      return accumulator || !Object.keys(current).includes(prop);
    }, false);
  });

  return missingProps;
}

const formatSchemaErrors = (customErrorFactory, schemaErrors, payload, mode = null, fieldMapping = null) => {
  // ------------------------------------------
  // Map over the schema errors and format according to standardised custom error format
  return schemaErrors.map(error => {
    console.log(error);
    let jsonPointer = error.data.path.replace(/["']/g, "").replace(/\[object Object\]/g, "");
    let jsonPointerSplit = jsonPointer.split('/');


    switch (error.data.keyword) {
      // -------------------------------------
      case 'required': {
        // -------------------------------------
        // 1001
        // Handle fieldName and fieldPointer conditionally on formatting mode
        let fieldName = (mode && mode === 'SPREADSHEET') ? fieldMapping.backTranslationProperties[error.data.params.missingProperty].ss_col : error.data.params.missingProperty;
        let row = (mode && mode === 'SPREADSHEET') ? payload.events[parseInt(jsonPointerSplit[1])].metadata.eventIndex + fieldMapping.starting_row : null;
        let fieldPointer = (mode && mode === 'SPREADSHEET') ? `${row},${fieldName}` : `${jsonPointer}/${error.data.params.missingProperty}`;
        let formattedError = customErrorFactory.getError('PropertyRequiredError', [fieldName, null, fieldPointer]);

        return formattedError;
      }
      case 'type': {
        // -------------------------------------
        if (error.data.params.type === 'null') {
          // DO NOT REPRODUCE NULL TYPE WHERE NULL IS PERMISSIBLE
          break;
        }
        // 1002
        let fieldName = (mode && mode === 'SPREADSHEET') ? fieldMapping.backTranslationProperties[jsonPointerSplit[jsonPointerSplit.length - 1]].ss_col : jsonPointerSplit[jsonPointerSplit.length - 1];
        let row = (mode && mode === 'SPREADSHEET') ? payload.events[parseInt(jsonPointerSplit[1])].metadata.eventIndex + fieldMapping.starting_row : null;
        let fieldPointer = (mode && mode === 'SPREADSHEET') ? `${row},${fieldName}` : jsonPointer;
        
        // Special handling for characteristic columns which have a column reference
        if (mode && mode === 'SPREADSHEET' && fieldName.includes('Ancillary Data')) {
          // -------------------------------------------
          let ancilliaryCol = payload.events[parseInt(jsonPointerSplit[1])].characteristic_measurement[parseInt(jsonPointerSplit[3])].raw_col_ref;
          fieldName = fieldName + (ancilliaryCol ? ancilliaryCol : '');
        }
        let formattedError = customErrorFactory.getError('PropertyTypeRequired', [fieldName, error.data.value, fieldPointer, (error.data.params.type !== 'string') ? error.data.params.type : 'text']);

        return formattedError;
      }
      case 'enum': {
        // -------------------------------------
        // 1003
        let fieldName = (mode && mode === 'SPREADSHEET') ? fieldMapping.backTranslationProperties[jsonPointerSplit[jsonPointerSplit.length - 1]].ss_col : jsonPointerSplit[jsonPointerSplit.length - 1];
        let row = (mode && mode === 'SPREADSHEET') ? payload.events[parseInt(jsonPointerSplit[1])].metadata.eventIndex + fieldMapping.starting_row : null;
        let fieldPointer = (mode && mode === 'SPREADSHEET') ? `${row},${fieldName}` : jsonPointer;

        // Special handling for specific enumerations
        let value = error.data.value
        let formattedError = customErrorFactory.getError('PropertyEnumError', [fieldName, value, fieldPointer, error.data.params.allowedValues]);
        // Unparseable mark configuration
        if (fieldPointer.includes('[Left_tibia,Left_tarsus,Right_tibia,Right_tarsus]') && value === 'UNPARSEABLE') {
          value = 'Value cannot be parsed';
          fieldPointer = `${row},Mark_configuration (col AF to AY)`;
          formattedError = customErrorFactory.getError('MarkConfigurationParsingError', [`row ${row}`, value, fieldPointer]);
        }
        else if (mode && mode === 'SPREADSHEET') {
          formattedError = customErrorFactory.getError('SpreadsheetPropertyEnumError', [fieldName, value, fieldPointer, fieldMapping.internal_version_id]);
        }

        return formattedError;
      }
      case 'minimum':
      case 'maximum': {
        // -------------------------------------
        // 1004
        let fieldName = (mode && mode === 'SPREADSHEET') ? fieldMapping.backTranslationProperties[jsonPointerSplit[jsonPointerSplit.length - 1]].ss_col : jsonPointerSplit[jsonPointerSplit.length - 1];
        let row = (mode && mode === 'SPREADSHEET') ? payload.events[parseInt(jsonPointerSplit[1])].metadata.eventIndex + fieldMapping.starting_row : null;
        let fieldPointer = (mode && mode === 'SPREADSHEET') ? `${row},${fieldName}` : jsonPointer;
        let formattedError = customErrorFactory.getError('PropertyLimitViolation', [fieldName, error.data.value, fieldPointer, error.data.keyword, error.data.params.limit]);

        return formattedError;
      }
      case 'format': {
        // -------------------------------------
        // 1005
        let fieldName = (mode && mode === 'SPREADSHEET') ? fieldMapping.backTranslationProperties[jsonPointerSplit[jsonPointerSplit.length - 1]].ss_col : jsonPointerSplit[jsonPointerSplit.length - 1];
        let row = (mode && mode === 'SPREADSHEET') ? payload.events[parseInt(jsonPointerSplit[1])].metadata.eventIndex + fieldMapping.starting_row : null;
        let fieldPointer = (mode && mode === 'SPREADSHEET') ? `${row},${fieldName}` : jsonPointer;
        let formattedError = customErrorFactory.getError('PropertyFormatError', [fieldName, error.data.value, fieldPointer, error.data.params.format]);
        return formattedError;
      }
      case 'pattern': {
        // -------------------------------------
        // 1006
        let fieldName = (mode && mode === 'SPREADSHEET') ? fieldMapping.backTranslationProperties[jsonPointerSplit[jsonPointerSplit.length - 1]].ss_col : jsonPointerSplit[jsonPointerSplit.length - 1];
        let row = (mode && mode === 'SPREADSHEET') ? payload.events[parseInt(jsonPointerSplit[1])].metadata.eventIndex + fieldMapping.starting_row : null;
        let fieldPointer = (mode && mode === 'SPREADSHEET') ? `${row},${fieldName}` : jsonPointer;
        let formattedError = customErrorFactory.getError('PropertyPatternError', [fieldName, error.data.value, fieldPointer, error.data.params.pattern]);

        if (mode && mode === 'SPREADSHEET' && (fieldPointer.includes('L3_number') || fieldPointer.includes('Bander_number'))) {
          formattedError = customErrorFactory.getError('InvalidBanderNumberFormat', [error.data.value, fieldPointer, fieldName]);
        }

        return formattedError;
      }
      case 'oneOf': {
        // -------------------------------------
        console.log('oneOf error encountered but deferred handling to sub-schemas');
        break;
      }
      case 'minItems': {
        // -------------------------------------
        // 1007
        let fieldName = (mode && mode === 'SPREADSHEET') ? fieldMapping.backTranslationProperties[jsonPointerSplit[jsonPointerSplit.length - 1]].ss_col : jsonPointerSplit[jsonPointerSplit.length - 1];
        let row = (mode && mode === 'SPREADSHEET') ? payload.events[parseInt(jsonPointerSplit[1])].metadata.eventIndex + fieldMapping.starting_row : null;
        let fieldPointer = (mode && mode === 'SPREADSHEET') ? `${row},${fieldName}` : jsonPointer;
        let formattedError = customErrorFactory.getError('MinItemsError', [fieldName, error.data.value, fieldPointer, error.data.params.limit]);

        return formattedError;
      }
      default: {
        // We aren't expecting any other schema error types to come through (unless the spreadseheet has been severely tampered with)
        // In this case is probably best to get in touch with the Banding Office,
        // Either:
        // 1) We can review the error and attempt to fix if it's our mistake, or,
        // 2) We can provide a clean version of the spreadsheet and explain the requirements of data format when submitting
        // 1008
        let fieldName = (mode && mode === 'SPREADSHEET') ? fieldMapping.backTranslationProperties[jsonPointerSplit[jsonPointerSplit.length - 1]].ss_col : jsonPointerSplit[jsonPointerSplit.length - 1];
        let row = (mode && mode === 'SPREADSHEET') ? payload.events[parseInt(jsonPointerSplit[1])].metadata.eventIndex + fieldMapping.starting_row : null;
        let fieldPointer = (mode && mode === 'SPREADSHEET') ? `${row},${fieldName}` : jsonPointer;
        let formattedError = customErrorFactory.getError('UnexpectedSchemaError', [fieldName, error.data.value, fieldPointer, JSON.stringify(error)]);

        return formattedError;
      }
    }
  }).filter(error => error);
}


const getPostLookupData = async (db, validations, data) => {
  // ------------------------------------------
  console.info('Getting post lookup data...');

  let lookupData = {
    "event": null,
    "markConfiguration": null,
    "bird": null,
    "species": null,
    "bander": null,
    "location": null
  }

  let markSearchCriteria = {
    'or': []
  };

  // -----------------------------------------
  // GET DATA RELATED TO EVENT (IF KNOWN)
  // -----------------------------------------
  if (validations.includes('event')) {
    // PLACEHOLDER NO LOOKUP DATA CURRENTLY REQUIRED
  }

  // -----------------------------------------
  // GET DATA RELATED TO THE MARK_CONFIGURATION (IF KNOWN)
  // -----------------------------------------
  if (validations.includes('event')
    && validations.includes('markConfiguration')) {
    // Want to see if we can pickup any stock that should be tracked (i.e. mark ids)
    // - This is based on the alphanumeric text which should match an existing stock item
    let STOCK_REGEX = /^([a-z0-9]+)-([a-z0-9]+)$/;

    // In-line function to process alphanumerics to search criteria
    let processAlphanumericsToSearchCriteria = (markConfig) => {
      if (markConfig.alphanumeric_text) {
        let match = markConfig.alphanumeric_text.toLowerCase().match(STOCK_REGEX);
        if (match) {
          markSearchCriteria.or.push({
            'prefix_number =': match[1],
            'short_number =': match[2]
          });
        }
      }
    }

    data.map(event => {
      // Filter each events mark_configuration_capture, mark_configuration_release 
      // to get the latest mark information where available
      event.mark_configuration_capture.filter(markConfig => {

        return markConfig.alphanumeric_text && markConfig.alphanumeric_text.toLowerCase().match(STOCK_REGEX);
      })
        .map(markConfig => {
          processAlphanumericsToSearchCriteria(markConfig);
        });

      event.mark_configuration_release.filter(markConfig => {
        return markConfig.alphanumeric_text && markConfig.alphanumeric_text.toLowerCase().match(STOCK_REGEX);
      })
        .map(markConfig => {
          processAlphanumericsToSearchCriteria(markConfig);
        });
    });

    console.log(JSON.stringify(markSearchCriteria));

    if (markSearchCriteria.or.length > 0) {
      lookupData.markConfiguration = await db.vw_mark_latest.find(markSearchCriteria);
      // CAN ALSO PREPOPULATE BIRD INFORMATION AT THIS POINT IF RELATED TO MARKS
      let birdSearchCriteria = {
        or: markSearchCriteria.or.map(criteria => {
          return {
            'vw_birds_to_marks.prefix_number = ': criteria['prefix_number ='],
            'vw_birds_to_marks.short_number = ': criteria['short_number =']
          }
        })
      }

      lookupData.bird = await db.vw_birds_to_marks.join({
        pk: 'id',
        vw_birds_to_first_marking_date: {
          type: 'LEFT OUTER',
          pk: 'id',
          on: { 'id': 'vw_birds_to_marks.id' },
          decomposeTo: 'object',
        },
        vw_birds_to_earliest_resighting: {
          type: 'LEFT OUTER',
          pk: 'id',
          on: { 'id': 'vw_birds_to_marks.id' },
          decomposeTo: 'object',
        }
      }).find(birdSearchCriteria);

      if (lookupData.bird.length > 0) {
        let statusCodeCriteria = {
          or: lookupData.bird.map(bird => {
            return {
              'id =': bird.id
            }
          })
        }

        let earliestDeathDates = await db.vw_birds_earliest_death_resighting.find(statusCodeCriteria);
        let latestAliveDates = await db.vw_birds_latest_alive_resighting.find(statusCodeCriteria);

        // Append earliest death date to lookup (join at DB level to parent query was too expensive)
        lookupData.bird.map(bird => {
          let deathDateSearch = earliestDeathDates.find(birdDeath => birdDeath.id === bird.id);
          bird.vw_birds_earliest_death_resighting = (typeof deathDateSearch !== 'undefined') ? deathDateSearch : null;
        });

        // Append earliest death date to lookup (join at DB level to parent query was too expensive)
        lookupData.bird.map(bird => {
          let aliveDateSearch = latestAliveDates.find(birdAlive => birdAlive.id === bird.id);
          bird.vw_birds_latest_alive_resighting = (typeof aliveDateSearch !== 'undefined') ? aliveDateSearch : null;
        });
      }
    }
  }

  // -----------------------------------------
  // GET DATA RELATED TO THE EXISTING BIRD (IF KNOWN)
  // -----------------------------------------
  if (validations.includes('event')
    && validations.includes('markConfiguration')
    && validations.includes('bird')) {
    // -----------------------------------------
    let speciesCriteria = {
      or: data.map(event => {
        return {
          'id =': event.bird.species_id
        }
      })
    }

    console.log(JSON.stringify(speciesCriteria));

    let speciesDetail = await db.species.find(speciesCriteria);
    lookupData.species = speciesDetail;
  }
  // -----------------------------------------
  // GET DATA RELATED TO THE BANDERS (IF KNOWN)
  // -----------------------------------------
  if (validations.includes('event')
    && validations.includes('markConfiguration')
    && validations.includes('bird')
    && validations.includes('bander')) {
    // -----------------------------------------
    let providerCriteria = data.map(record => {
      return {
        'bander_id::text =': record.event.event_provider_id
      }
    });
    let reporterCriteria = data.map(record => {
      return {
        'bander_id::text =': record.event.event_reporter_id
      }
    });

    let banderSearchCriteria = {
      or: [...providerCriteria, ...reporterCriteria]
    }

    console.log(banderSearchCriteria);

    if (banderSearchCriteria.or.length > 0) {
      lookupData.bander = await db.vw_maximum_certification_level.find(banderSearchCriteria);
    }
  }

  // -----------------------------------------
  // GET DATA RELATED TO LOCATION (IF KNOWN)
  // -----------------------------------------
  if (validations.includes('event')
    && validations.includes('markConfiguration')
    && validations.includes('bird')
    && validations.includes('bander')
    && validations.includes('location')) {
    // -----------------------------------------
    // PLACEHOLDER - CURRENTLY NO LOCATION LOOKUP REQUIRED
  }

  console.log(`LOOKUP DATA: ${JSON.stringify(lookupData)}`);
  return lookupData;
}


const getPutLookupData = async (db, validations, event, data, currentEvent) => {
  // ------------------------------------------
  console.info('Getting put lookup data...');

  let currenEventId = event.pathParameters.eventId;

  let lookupData = {
    "currentEvent": currentEvent,
    "event": null,
    "markConfiguration": null,
    "bird": null,
    "birdIds": null,
    "species": null,
    "bander": null,
    "location": null
  }

  let markSearchCriteria = {
    'or': []
  };

  // -----------------------------------------
  // GET DATA RELATED TO EVENT (IF KNOWN)
  // -----------------------------------------
  if (validations.includes('event')) {
    // PLACEHOLDER NO LOOKUP DATA CURRENTLY REQUIRED
  }

  // -----------------------------------------
  // GET DATA RELATED TO THE MARK_CONFIGURATION (IF KNOWN)
  // -----------------------------------------
  if (validations.includes('event')
    && validations.includes('markConfiguration')) {
    // Want to see if we can pickup any stock that should be tracked (i.e. mark ids)
    // - This is based on the alphanumeric text which should match an existing stock item
    let STOCK_REGEX = /^([a-z0-9]+)-([a-z0-9]+)$/;

    // In-line function to process alphanumerics to search criteria
    let processAlphanumericsToSearchCriteria = (markConfig) => {
      if (markConfig.alphanumeric_text) {
        let match = markConfig.alphanumeric_text.toLowerCase().match(STOCK_REGEX);
        if (match) {
          markSearchCriteria.or.push({
            'prefix_number =': match[1],
            'short_number =': match[2]
          });
        }
      }
    }

    data.map(event => {
      // Filter each events mark_configuration_capture, mark_configuration_release 
      // to get the latest mark information where available
      event.mark_configuration.filter(markConfig => {

        return markConfig.alphanumeric_text && markConfig.alphanumeric_text.toLowerCase().match(STOCK_REGEX);
      })
        .map(markConfig => {
          processAlphanumericsToSearchCriteria(markConfig);
        });
    });

    console.log(JSON.stringify(markSearchCriteria));

    if (markSearchCriteria.or.length > 0) {
      lookupData.markConfiguration = await db.vw_mark_latest.find(markSearchCriteria);
      // CAN ALSO PREPOPULATE BIRD INFORMATION AT THIS POINT IF RELATED TO MARKS
      let birdSearchCriteria = {
        or: markSearchCriteria.or.map(criteria => {
          return {
            'vw_birds_to_marks.prefix_number = ': criteria['prefix_number ='],
            'vw_birds_to_marks.short_number = ': criteria['short_number =']
          }
        })
      }

      lookupData.bird = await db.vw_birds_to_marks.join({
        pk: 'id',
        vw_birds_to_first_marking_date: {
          type: 'LEFT OUTER',
          pk: 'id',
          on: { 'id': 'vw_birds_to_marks.id' },
          decomposeTo: 'object',
        },
        vw_birds_to_earliest_resighting: {
          type: 'LEFT OUTER',
          pk: 'id',
          on: { 'id': 'vw_birds_to_marks.id' },
          decomposeTo: 'object',
        }
      }).find(birdSearchCriteria);

      if (lookupData.bird.length > 0) {
        let statusCodeCriteria = {
          or: lookupData.bird.map(bird => {
            return {
              'id =': bird.id
            }
          })
        }

        let earliestDeathDates = await db.vw_birds_earliest_death_resighting.find(statusCodeCriteria);
        let latestAliveDates = await db.vw_birds_latest_alive_resighting.find(statusCodeCriteria);

        // Append earliest death date to lookup (join at DB level to parent query was too expensive)
        lookupData.bird.map(bird => {
          let deathDateSearch = earliestDeathDates.find(birdDeath => birdDeath.id === bird.id);
          bird.vw_birds_earliest_death_resighting = (typeof deathDateSearch !== 'undefined') ? deathDateSearch : null;
        });

        // Append earliest death date to lookup (join at DB level to parent query was too expensive)
        lookupData.bird.map(bird => {
          let aliveDateSearch = latestAliveDates.find(birdAlive => birdAlive.id === bird.id);
          bird.vw_birds_latest_alive_resighting = (typeof aliveDateSearch !== 'undefined') ? aliveDateSearch : null;
        });
      }
    }
  }

  // -----------------------------------------
  // GET DATA RELATED TO THE EXISTING BIRD (IF KNOWN)
  // -----------------------------------------
  if (validations.includes('event')
    && validations.includes('markConfiguration')
    && validations.includes('bird')) {
    // -----------------------------------------
    let speciesCriteria = {
      or: data.map(event => {
        return {
          'id =': event.bird.species_id
        }
      })
    }

    speciesCriteria.or.push({ 'id =': currentEvent[0].bird.species_id });

    console.log(JSON.stringify(speciesCriteria));

    let speciesDetail = await db.species.find(speciesCriteria);
    lookupData.species = speciesDetail;

    let birdIdCriteria = {
      or: data.map(event => {
        return {
          'id =': event.bird.id
        }
      })
    }

    console.log(JSON.stringify(birdIdCriteria));

    let birdIds = await db.vw_bird_detail.join({
      pk: 'id',
      vw_birds_to_first_marking_date: {
        type: 'LEFT OUTER',
        pk: 'id',
        on: { 'id': 'vw_bird_detail.id' },
        decomposeTo: 'object',
      },
      vw_birds_to_earliest_resighting: {
        type: 'LEFT OUTER',
        pk: 'id',
        on: { 'id': 'vw_bird_detail.id' },
        decomposeTo: 'object',
      }
    }).find(birdIdCriteria);

    lookupData.birdIds = birdIds;

    let earliestDeathDates = await db.vw_birds_earliest_death_resighting.find(birdIdCriteria);
    let latestAliveDates = await db.vw_birds_latest_alive_resighting.find(birdIdCriteria);

    // Append earliest death date to lookup (join at DB level to parent query was too expensive)
    lookupData.birdIds.map(bird => {
      let deathDateSearch = earliestDeathDates.find(birdDeath => birdDeath.id === bird.id);
      bird.vw_birds_earliest_death_resighting = (typeof deathDateSearch !== 'undefined') ? deathDateSearch : null;
    });

    // Append earliest death date to lookup (join at DB level to parent query was too expensive)
    lookupData.birdIds.map(bird => {
      let aliveDateSearch = latestAliveDates.find(birdAlive => birdAlive.id === bird.id);
      bird.vw_birds_latest_alive_resighting = (typeof aliveDateSearch !== 'undefined') ? aliveDateSearch : null;
    });
  }

  // -----------------------------------------
  // GET DATA RELATED TO THE BANDERS (IF KNOWN)
  // -----------------------------------------
  if (validations.includes('event')
    && validations.includes('markConfiguration')
    && validations.includes('bird')
    && validations.includes('bander')) {
    // -----------------------------------------
    let providerCriteria = data.map(record => {
      return {
        'bander_id::text =': record.event.event_provider_id
      }
    });
    let reporterCriteria = data.map(record => {
      return {
        'bander_id::text =': record.event.event_reporter_id
      }
    });

    let banderSearchCriteria = {
      or: [...providerCriteria, ...reporterCriteria]
    }

    console.log(banderSearchCriteria);

    if (banderSearchCriteria.or.length > 0) {
      lookupData.bander = await db.vw_maximum_certification_level.find(banderSearchCriteria);
    }
  }

  // -----------------------------------------
  // GET DATA RELATED TO LOCATION (IF KNOWN)
  // -----------------------------------------
  if (validations.includes('event')
    && validations.includes('markConfiguration')
    && validations.includes('bird')
    && validations.includes('bander')
    && validations.includes('location')) {
    // -----------------------------------------
    // PLACEHOLDER - CURRENTLY NO LOCATION LOOKUP REQUIRED
  }

  console.log(`LOOKUP DATA: ${JSON.stringify(lookupData)}`);
  return lookupData;
}


const getSpreadsheetLookupData = async (db, validations, data) => {
  // ------------------------------------------
  console.info('Getting spreadsheet lookup data...');

  let lookupData = {
    "event": null,
    "markConfiguration": null,
    "characteristicMeasurement": null,
    "bird": null,
    "species": null,
    "bander": null,
    "location": null
  }

  let markSearchCriteria = {
    'or': []
  };

  // -----------------------------------------
  // GET DATA RELATED TO EVENT (IF KNOWN)
  // -----------------------------------------
  if (validations.includes('event')) {
    // PLACEHOLDER NO LOOKUP DATA CURRENTLY REQUIRED
  }

  // -----------------------------------------
  // GET DATA RELATED TO THE MARK_CONFIGURATION (IF KNOWN)
  // -----------------------------------------
  if (validations.includes('event')
    && validations.includes('markConfiguration')) {
    // Want to see if we can pickup any stock that should be tracked (i.e. mark ids)
    // - This is based on the alphanumeric text which should match an existing stock item
    let STOCK_REGEX = /^([a-z0-9]+)-([a-z0-9]+)$/;

    // In-line function to process alphanumerics to search criteria
    let processAlphanumericsToSearchCriteria = (markConfig) => {
      if (markConfig.alphanumeric_text) {
        let match = markConfig.alphanumeric_text.toLowerCase().match(STOCK_REGEX);
        if (match) {
          markSearchCriteria.or.push({
            'prefix_number =': match[1],
            'short_number =': match[2]
          });
        }
      }
    }

    data.map(event => {
      // Filter each events mark_configuration_capture, mark_configuration_release 
      // to get the latest mark information where available
      event.mark_configuration.filter(markConfig => {

        return markConfig.alphanumeric_text && markConfig.alphanumeric_text.toLowerCase().match(STOCK_REGEX);
      })
        .map(markConfig => {
          processAlphanumericsToSearchCriteria(markConfig);
        });
    });

    console.log(JSON.stringify(markSearchCriteria));

    if (markSearchCriteria.or.length > 0) {
      lookupData.markConfiguration = await db.vw_mark_latest.find(markSearchCriteria);
      // CAN ALSO PREPOPULATE BIRD INFORMATION AT THIS POINT IF RELATED TO MARKS
      let birdSearchCriteria = {
        or: markSearchCriteria.or.map(criteria => {
          return {
            'vw_birds_to_marks.prefix_number = ': criteria['prefix_number ='],
            'vw_birds_to_marks.short_number = ': criteria['short_number =']
          }
        })
      }

      lookupData.bird = await db.vw_birds_to_marks.join({
        pk: 'id',
        vw_birds_to_first_marking_date: {
          type: 'LEFT OUTER',
          pk: 'id',
          on: { 'id': 'vw_birds_to_marks.id' },
          decomposeTo: 'object',
        },
        vw_birds_to_earliest_resighting: {
          type: 'LEFT OUTER',
          pk: 'id',
          on: { 'id': 'vw_birds_to_marks.id' },
          decomposeTo: 'object',
        }
      }).find(birdSearchCriteria);

      if (lookupData.bird.length > 0) {
        let statusCodeCriteria = {
          or: lookupData.bird.map(bird => {
            return {
              'id =': bird.id
            }
          })
        }

        let earliestDeathDates = await db.vw_birds_earliest_death_resighting.find(statusCodeCriteria);
        let latestAliveDates = await db.vw_birds_latest_alive_resighting.find(statusCodeCriteria);

        // Append earliest death date to lookup (join at DB level to parent query was too expensive)
        lookupData.bird.map(bird => {
          let deathDateSearch = earliestDeathDates.find(birdDeath => birdDeath.id === bird.id);
          bird.vw_birds_earliest_death_resighting = (typeof deathDateSearch !== 'undefined') ? deathDateSearch : null;
        });

        // Append earliest death date to lookup (join at DB level to parent query was too expensive)
        lookupData.bird.map(bird => {
          let aliveDateSearch = latestAliveDates.find(birdAlive => birdAlive.id === bird.id);
          bird.vw_birds_latest_alive_resighting = (typeof aliveDateSearch !== 'undefined') ? aliveDateSearch : null;
        });
      }
    }
  }

  // -----------------------------------------
  // GET DATA RELATED TO THE CHARACTERISTIC_MEASUREMENTS
  // -----------------------------------------
  if (validations.includes('event')
    && validations.includes('markConfiguration')
    && validations.includes('characteristicMeasurement')) {

    let characteristics = await db.characteristic.find();
    lookupData.characteristicMeasurement = characteristics;
  }

  // -----------------------------------------
  // GET DATA RELATED TO THE EXISTING BIRD (IF KNOWN)
  // -----------------------------------------
  if (validations.includes('event')
    && validations.includes('markConfiguration')
    && validations.includes('characteristicMeasurement')
    && validations.includes('bird')) {
    // -----------------------------------------
    let speciesCriteria = {
      or: data.map(event => {
        return {
          'species_code_nznbbs =': event.bird.raw_species_code_nznbbs
        }
      })
    }

    console.log(JSON.stringify(speciesCriteria));

    let speciesDetail = await db.species.find(speciesCriteria);
    lookupData.species = speciesDetail;
  }
  // -----------------------------------------
  // GET DATA RELATED TO THE BANDERS (IF KNOWN)
  // -----------------------------------------
  if (validations.includes('event')
    && validations.includes('markConfiguration')
    && validations.includes('bird')
    && validations.includes('bander')) {
    // -----------------------------------------
    let providerCriteria = data.map(record => {
      return {
        'nznbbs_certification_number =': record.event.raw_event_provider_nznbbs_certification_number
      }
    });
    let reporterCriteria = data.map(record => {
      return {
        'nznbbs_certification_number =': record.event.raw_event_reporter_nznbbs_certification_number
      }
    });

    let banderSearchCriteria = {
      or: [...providerCriteria, ...reporterCriteria]
    }

    console.log(banderSearchCriteria);

    if (banderSearchCriteria.or.length > 0) {
      lookupData.bander = await db.vw_maximum_certification_level.find(banderSearchCriteria);
    }
  }

  // -----------------------------------------
  // GET DATA RELATED TO LOCATION (IF KNOWN)
  // -----------------------------------------
  if (validations.includes('event')
    && validations.includes('markConfiguration')
    && validations.includes('bird')
    && validations.includes('bander')
    && validations.includes('location')) {
    // -----------------------------------------
    // PLACEHOLDER - CURRENTLY NO LOCATION LOOKUP REQUIRED
  }

  console.log(`LOOKUP DATA: ${JSON.stringify(lookupData)}`);
  return lookupData;
}


const supplementPostEventWithLookupData = (validations, data, lookupData) => {
  // ------------------------------------------
  console.info('Supplementing post data payload with lookup data...');

  // Clone the event data
  let response = _.cloneDeep(data);

  // -----------------------------------------
  // SUPPLEMENT DATA RELATED TO EVENT (IF KNOWN)
  // -----------------------------------------
  if (validations.includes('event') && lookupData.event) {
    // PLACEHOLDER NO LOOKUP DATA CURRENTLY RETURNED
  }

  // -----------------------------------------
  // SUPPLEMENT DATA RELATED TO THE MARK_CONFIGURATION (IF KNOWN)
  // -----------------------------------------
  if (validations.includes('markConfiguration') && lookupData.markConfiguration) {
    // ----------------------------------------------------

    // In line function to format markConfig based on lookup data
    const formatMarkConfig = (markConfig, refMarkDetail) => {
      // ---------------------------------
      if (markConfig.alphanumeric_text
        && markConfig.alphanumeric_text.toLowerCase() === `${refMarkDetail.prefix_number}-${refMarkDetail.short_number}`) {
        return {
          ...markConfig,
          mark_id: refMarkDetail.id,
          validation_prefix_number: refMarkDetail.prefix_number,
          validation_short_number: refMarkDetail.short_number,
          validation_state: refMarkDetail.check_mark_state,
          validation_bander_id: refMarkDetail.bander_id,
          validation_last_event_timestamp: refMarkDetail.event_timestamp
        }
      }
      return markConfig;
    }

    // In line function to format markConfig based on lookup data
    const formatUnlinkedMarkConfig = (markConfig) => {
      // ---------------------------------
      if (typeof markConfig.mark_id === 'undefined') {
        return {
          ...markConfig,
          mark_id: null,
          validation_prefix_number: null,
          validation_short_number: null,
          validation_state: null,
          validation_bander_id: null
        }
      }
      return markConfig;
    }

    lookupData.markConfiguration.map(refMarkDetail => {
      // For each mark configuration looked up, supplement the event mark configuration
      response.map(record => {
        // CAPTURE
        record.mark_configuration_capture = record.mark_configuration_capture.map(markConfig => {
          // For each capture markConfig, add supplementary information
          return formatMarkConfig(markConfig, refMarkDetail);
        });

        // RELEASE
        record.mark_configuration_release = record.mark_configuration_release.map(markConfig => {
          // For each capture markConfig, add supplementary information
          return formatMarkConfig(markConfig, refMarkDetail);
        });
      });
    });

    response.map(record => {
      // POPULATE UNLINKED MARK CONFIGURATION
      record.mark_configuration_capture = record.mark_configuration_capture.map(markConfig => {
        return formatUnlinkedMarkConfig(markConfig);
      });

      record.mark_configuration_release = record.mark_configuration_release.map(markConfig => {
        // For each capture markCon
        return formatUnlinkedMarkConfig(markConfig);
      });
    });

    // If we have bird data at this point, return with the validation to assist in the UI
    if (lookupData.bird) {
      response.map(record => {
        let birdSearch = lookupData.bird.find(birdDetail => {
          return (
            typeof record.mark_configuration_capture.find(markConfig => {
              return (markConfig.alphanumeric_text
                && markConfig.alphanumeric_text.toLowerCase() === `${birdDetail.prefix_number}-${birdDetail.short_number}`);
            }) !== 'undefined'
            || typeof record.mark_configuration_release.find(markConfig => {
              return (markConfig.alphanumeric_text
                && markConfig.alphanumeric_text.toLowerCase() === `${birdDetail.prefix_number}-${birdDetail.short_number}`);
            }) !== 'undefined'
          );
        });

        let possibleBirdIds = [...new Set(lookupData.bird.filter(birdDetail => {
          return (
            typeof record.mark_configuration_capture.find(markConfig => {
              return (markConfig.alphanumeric_text
                && markConfig.alphanumeric_text.toLowerCase() === `${birdDetail.prefix_number}-${birdDetail.short_number}`);
            }) !== 'undefined'
            || typeof record.mark_configuration_release.find(markConfig => {
              return (markConfig.alphanumeric_text
                && markConfig.alphanumeric_text.toLowerCase() === `${birdDetail.prefix_number}-${birdDetail.short_number}`);
            }) !== 'undefined'
          );
        }).map(birdDetail => birdDetail.id))];
        console.log(`Possible bird-ids: ${possibleBirdIds}`);
        console.log(`Number of unique bird associations possible: ${possibleBirdIds.length}`);
        record.bird.bird_association_length = possibleBirdIds.length;

        // IF WE'VE FOUND A BIRD TO LINK TO, UPDATE THE SPECIES CODE AND BIRD-ID TO ASSIST THE UI
        if (typeof birdSearch !== 'undefined') {
          record.bird.id = birdSearch.id;
          record.bird.species_id = (record.bird.id) ? record.bird.species_id : birdSearch.species_id;
          record.bird.validation_id = null;
          record.bird.validation_species_id = birdSearch.species_id;
          record.bird.validation_species_common_name = birdSearch.common_name_nznbbs;
          record.bird.validation_valid_band_prefixes = birdSearch.valid_band_prefixes;
          record.bird.validation_first_marking_timestamp = ('vw_birds_to_first_marking_date' in birdSearch) ? birdSearch.vw_birds_to_first_marking_date.first_marking_timestamp : null;
          record.bird.validation_first_marking_id = ('vw_birds_to_first_marking_date' in birdSearch) ? birdSearch.vw_birds_to_first_marking_date.event_id : null;
          record.bird.validation_earliest_death_resighting = ('vw_birds_earliest_death_resighting' in birdSearch && birdSearch.vw_birds_earliest_death_resighting) ? birdSearch.vw_birds_earliest_death_resighting.earliest_dead_timestamp : null;
          record.bird.validation_latest_alive_resighting = ('vw_birds_latest_alive_resighting' in birdSearch && birdSearch.vw_birds_latest_alive_resighting) ? birdSearch.vw_birds_latest_alive_resighting.latest_alive_timestamp : null;
        }
      })
    }
  }

  // -----------------------------------------
  // SUPPLEMENT DATA RELATED TO THE EXISTING BIRD (IF KNOWN)
  // -----------------------------------------
  if (validations.includes('bird') && lookupData.species) {
    console.log('Lookup species: ', lookupData.species);

    response.map(record => {
      // ------------------------------------
      let speciesSearch = lookupData.species.find(speciesDetail => {
        return record.bird.species_id && record.bird.species_id === speciesDetail.id;
      });

      record.bird.species_common_name = (typeof speciesSearch !== 'undefined') ? speciesSearch.common_name_nznbbs : null;
      record.bird.validation_valid_band_prefixes = (typeof speciesSearch !== 'undefined') ? speciesSearch.valid_band_prefixes : null;
    })
  }

  // -----------------------------------------
  // SUPPLEMENT DATA RELATED TO THE BANDERS (IF KNOWN)
  // -----------------------------------------
  if (validations.includes('bander') && lookupData.bander) {
    // PlACEHOLDER, CURRENTLY NO BANDER VALIDATION REQUIRED
  }

  // -----------------------------------------
  // SUPPLEMENT DATA RELATED TO LOCATION (IF KNOWN)
  // -----------------------------------------
  if (validations.includes('location') && lookupData.location) {
    // PlACEHOLDER, CURRENTLY NO LOOKUP DATA REQUIRED
  }

  console.log(response);
  console.log(JSON.stringify(response));
  return response;
}


const supplementPutEventWithLookupData = (validations, data, lookupData) => {
  // ------------------------------------------
  console.info('Supplementing put data payload with lookup data...');

  // Clone the event data
  let response = _.cloneDeep(data);

  // SUPPLEMENT WITH DATA RELATED TO CURRENT EVENT
  if (lookupData.currentEvent) {
    response.map(record => {
      // ------------------------------------
      record.bird.validation_id = lookupData.currentEvent[0].bird.id;
    });
  }

  // -----------------------------------------
  // SUPPLEMENT DATA RELATED TO EVENT (IF KNOWN)
  // -----------------------------------------
  if (validations.includes('event') && lookupData.event) {
    // PLACEHOLDER NO LOOKUP DATA CURRENTLY RETURNED
  }

  // -----------------------------------------
  // SUPPLEMENT DATA RELATED TO THE MARK_CONFIGURATION (IF KNOWN)
  // -----------------------------------------
  if (validations.includes('markConfiguration') && lookupData.markConfiguration) {
    // ----------------------------------------------------

    // In line function to format markConfig based on lookup data
    const formatMarkConfig = (markConfig, refMarkDetail) => {
      // ---------------------------------
      if (markConfig.alphanumeric_text
        && markConfig.alphanumeric_text.toLowerCase() === `${refMarkDetail.prefix_number}-${refMarkDetail.short_number}`) {
        return {
          ...markConfig,
          mark_id: refMarkDetail.id,
          validation_prefix_number: refMarkDetail.prefix_number,
          validation_short_number: refMarkDetail.short_number,
          validation_state: (refMarkDetail.check_mark_state_event_id !== lookupData.currentEvent[0].id) ? refMarkDetail.check_mark_state : null,
          validation_bander_id: refMarkDetail.bander_id,
          validation_last_event_timestamp: refMarkDetail.event_timestamp
        }
      }
      return markConfig;
    }

    // In line function to format markConfig based on lookup data
    const formatUnlinkedMarkConfig = (markConfig) => {
      // ---------------------------------
      if (typeof markConfig.mark_id === 'undefined') {
        return {
          ...markConfig,
          mark_id: null,
          validation_prefix_number: null,
          validation_short_number: null,
          validation_state: null,
          validation_bander_id: null
        }
      }
      return markConfig;
    }

    lookupData.markConfiguration.map(refMarkDetail => {
      // For each mark configuration looked up, supplement the event mark configuration
      response.map(record => {
        // CAPTURE
        record.mark_configuration = record.mark_configuration.map(markConfig => {
          // For each capture markConfig, add supplementary information
          return formatMarkConfig(markConfig, refMarkDetail);
        });
      });
    });

    response.map(record => {
      // POPULATE UNLINKED MARK CONFIGURATION
      record.mark_configuration = record.mark_configuration.map(markConfig => {
        return formatUnlinkedMarkConfig(markConfig);
      });
    });

    // If we have bird data at this point, return with the validation to assist in the UI
    if (lookupData.bird) {
      response.map(record => {
        // Check if the bird_id is being overridden by and admin user 
        // and if so, do not automatically lookup bird_id based on marks along
        let overrideBirdIdAttempt = lookupData.currentEvent[0].bird.id !== record.bird.id;
        console.log(`Override attempt for bird_id: ${overrideBirdIdAttempt}`);
        record.bird.override_bird_id_attempt = overrideBirdIdAttempt;

        let birdSearch = lookupData.bird.find(birdDetail => {
          return (
            typeof record.mark_configuration.find(markConfig => {
              return (markConfig.alphanumeric_text
                && markConfig.alphanumeric_text.toLowerCase() === `${birdDetail.prefix_number}-${birdDetail.short_number}`);
            }) !== 'undefined'
          );
        });

        let possibleBirdIds = [...new Set(lookupData.bird.filter(birdDetail => {
          return (
            typeof record.mark_configuration.find(markConfig => {
              return (markConfig.alphanumeric_text
                && markConfig.alphanumeric_text.toLowerCase() === `${birdDetail.prefix_number}-${birdDetail.short_number}`);
            }) !== 'undefined'
          );
        }).map(birdDetail => birdDetail.id))];
        console.log(`Possible bird-ids: ${possibleBirdIds}`);
        console.log(`Number of unique bird associations possible: ${possibleBirdIds.length}`);
        record.bird.bird_association_length = possibleBirdIds.length;

        // IF WE'VE FOUND A BIRD TO LINK TO, UPDATE THE SPECIES CODE AND BIRD-ID TO ASSIST THE UI
        if (!overrideBirdIdAttempt && typeof birdSearch !== 'undefined') {
          // --------------------------------------
          // Bird linkage based on marks
          // --------------------------------------
          record.bird.id = birdSearch.id;
          record.bird.friendly_name = (birdSearch.friendly_name) ? birdSearch.friendly_name : null;
          record.bird.species_id = (record.bird.id) ? record.bird.species_id : birdSearch.species_id;
          record.bird.validation_species_id = birdSearch.species_id;
          record.bird.validation_species_common_name = birdSearch.common_name_nznbbs;
          record.bird.validation_valid_band_prefixes = birdSearch.valid_band_prefixes;
          record.bird.validation_first_marking_timestamp = ('vw_birds_to_first_marking_date' in birdSearch) ? birdSearch.vw_birds_to_first_marking_date.first_marking_timestamp : null;
          record.bird.validation_first_marking_id = ('vw_birds_to_first_marking_date' in birdSearch) ? birdSearch.vw_birds_to_first_marking_date.event_id : null;
          record.bird.validation_earliest_death_resighting = ('vw_birds_earliest_death_resighting' in birdSearch && birdSearch.vw_birds_earliest_death_resighting) ? birdSearch.vw_birds_earliest_death_resighting.earliest_dead_timestamp : null;
          record.bird.validation_latest_alive_resighting = ('vw_birds_latest_alive_resighting' in birdSearch && birdSearch.vw_birds_latest_alive_resighting) ? birdSearch.vw_birds_latest_alive_resighting.latest_alive_timestamp : null;
        }
        else {
          // No bird has been found based on the mark_configuration, 
          //    validation still should occur against existing record details where known
          record.bird.id = record.bird.id;
          record.bird.friendly_name = (record.bird.friendly_name) ? record.bird.friendly_name : lookupData.currentEvent[0].bird.friendly_name;
          record.bird.species_id = (record.bird.id) ? record.bird.species_id : lookupData.currentEvent[0].bird.species_id;
          record.bird.validation_species_id = lookupData.currentEvent[0].bird.species_id;
          record.bird.validation_first_marking_timestamp = null;
          record.bird.validation_first_marking_id = null;
          record.bird.validation_earliest_death_resighting = null;
          record.bird.validation_latest_alive_resighting = null;
        }
      });
    }
  }

  // -----------------------------------------
  // SUPPLEMENT DATA RELATED TO THE EXISTING BIRD (IF KNOWN)
  // -----------------------------------------
  if (validations.includes('bird') && lookupData.species) {
    console.log('Lookup species: ', lookupData.species);

    response.map(record => {
      // ------------------------------------
      let speciesSearch = lookupData.species.find(speciesDetail => {
        return record.bird.species_id && record.bird.species_id === speciesDetail.id;
      });

      let currentEventSpeciesSearch = lookupData.species.find(speciesDetail => {
        return lookupData.currentEvent[0].bird.species_id === speciesDetail.id;
      });

      let overrideBirdIdAttempt = lookupData.currentEvent[0].bird.id !== record.bird.id;
      console.log(`Override attempt for bird_id: ${overrideBirdIdAttempt}`);

      let birdSearchById = lookupData.birdIds.find(birdDetail => {
        return record.bird.id === birdDetail.id;
      });


      if (overrideBirdIdAttempt && typeof birdSearchById !== 'undefined') {
        // --------------------------------------
        // Admin-user selected bird_id override
        // --------------------------------------
        console.log(`Direct bird-id search ${JSON.stringify(birdSearchById)}`);

        record.bird.id = birdSearchById.id;
        record.bird.friendly_name = (birdSearchById.friendly_name) ? birdSearchById.friendly_name : null;
        record.bird.species_id = (record.bird.id) ? birdSearchById.species_id : record.bird.species_id;
        record.bird.species_common_name = birdSearchById.common_name_nznbbs;
        record.bird.validation_species_id = record.bird.species_id;
        record.bird.validation_species_common_name = birdSearchById.common_name_nznbbs;
        record.bird.validation_valid_band_prefixes = birdSearchById.valid_band_prefixes;
        record.bird.validation_first_marking_timestamp = ('vw_birds_to_first_marking_date' in birdSearchById) ? birdSearchById.vw_birds_to_first_marking_date.first_marking_timestamp : null;
        record.bird.validation_first_marking_id = ('vw_birds_to_first_marking_date' in birdSearchById) ? birdSearchById.vw_birds_to_first_marking_date.event_id : null;
        record.bird.validation_earliest_death_resighting = ('vw_birds_earliest_death_resighting' in birdSearchById && birdSearchById.vw_birds_earliest_death_resighting) ? birdSearchById.vw_birds_earliest_death_resighting.earliest_dead_timestamp : null;
        record.bird.validation_latest_alive_resighting = ('vw_birds_latest_alive_resighting' in birdSearchById && birdSearchById.vw_birds_latest_alive_resighting) ? birdSearchById.vw_birds_latest_alive_resighting.latest_alive_timestamp : null;
      }
      else if (typeof birdSearchById !== 'undefined') {
        // --------------------------------------
        // Bird linkage based on bird-id without override
        // --------------------------------------
        record.bird.id = record.bird.id;
        record.bird.friendly_name = (birdSearchById.friendly_name) ? birdSearchById.friendly_name : null;
        record.bird.species_id = (record.bird.id) ? record.bird.species_id : birdSearchById.species_id;
        record.bird.validation_species_id = birdSearchById.species_id;
        record.bird.validation_species_common_name = birdSearchById.common_name_nznbbs;
        record.bird.validation_valid_band_prefixes = birdSearchById.valid_band_prefixes;
        record.bird.validation_first_marking_timestamp = ('vw_birds_to_first_marking_date' in birdSearchById) ? birdSearchById.vw_birds_to_first_marking_date.first_marking_timestamp : null;
        record.bird.validation_first_marking_id = ('vw_birds_to_first_marking_date' in birdSearchById) ? birdSearchById.vw_birds_to_first_marking_date.event_id : null;
        record.bird.validation_earliest_death_resighting = ('vw_birds_earliest_death_resighting' in birdSearchById && birdSearchById.vw_birds_earliest_death_resighting) ? birdSearchById.vw_birds_earliest_death_resighting.earliest_dead_timestamp : null;
        record.bird.validation_latest_alive_resighting = ('vw_birds_latest_alive_resighting' in birdSearchById && birdSearchById.vw_birds_latest_alive_resighting) ? birdSearchById.vw_birds_latest_alive_resighting.latest_alive_timestamp : null;
      }
      else {
        record.bird.validation_species_id = (typeof record.bird.validation_species_id !== 'undefined') ? record.bird.validation_species_id : lookupData.currentEvent[0].bird.species_id;
        record.bird.species_common_name = (typeof speciesSearch !== 'undefined') ? speciesSearch.common_name_nznbbs : null;
        record.bird.validation_species_common_name = (typeof currentEventSpeciesSearch !== 'undefined') ? currentEventSpeciesSearch.common_name_nznbbs : null;
        record.bird.validation_valid_band_prefixes = (typeof speciesSearch !== 'undefined') ? speciesSearch.valid_band_prefixes : null;
      }

      let birdIdSearch = lookupData.birdIds.find(birdDetail => {
        return record.bird.id && record.bird.id === birdDetail.id;
      });

      record.bird.validation_id_exists = (typeof birdIdSearch !== 'undefined') ? true : false;
    });
  }
  // -----------------------------------------
  // SUPPLEMENT DATA RELATED TO THE BANDERS (IF KNOWN)
  // -----------------------------------------
  if (validations.includes('bander') && lookupData.bander) {
    // PlACEHOLDER, CURRENTLY NO BANDER VALIDATION REQUIRED
  }

  // -----------------------------------------
  // SUPPLEMENT DATA RELATED TO LOCATION (IF KNOWN)
  // -----------------------------------------
  if (validations.includes('location') && lookupData.location) {
    // PlACEHOLDER, CURRENTLY NO LOOKUP DATA REQUIRED
  }

  console.log(JSON.stringify(response));
  return response;
}


const supplementSpreadsheetEventsWithLookupData = (validations, data, lookupData) => {
  // ------------------------------------------
  console.info('Supplementing post data payload with lookup data...');

  // Clone the event data
  let response = _.cloneDeep(data);

  // -----------------------------------------
  // SUPPLEMENT DATA RELATED TO EVENT (IF KNOWN)
  // -----------------------------------------
  if (validations.includes('event') && lookupData.event) {
    // PLACEHOLDER NO LOOKUP DATA CURRENTLY RETURNED
  }

  // -----------------------------------------
  // SUPPLEMENT DATA RELATED TO THE MARK_CONFIGURATION (IF KNOWN)
  // -----------------------------------------
  if (validations.includes('markConfiguration') && lookupData.markConfiguration) {
    // ----------------------------------------------------

    // In line function to format markConfig based on lookup data
    const formatMarkConfig = (markConfig, refMarkDetail) => {
      // ---------------------------------
      if (markConfig.alphanumeric_text
        && markConfig.alphanumeric_text.toLowerCase() === `${refMarkDetail.prefix_number}-${refMarkDetail.short_number}`) {
        return {
          ...markConfig,
          mark_id: refMarkDetail.id,
          validation_prefix_number: refMarkDetail.prefix_number,
          validation_short_number: refMarkDetail.short_number,
          validation_state: refMarkDetail.check_mark_state,
          validation_bander_id: refMarkDetail.bander_id,
          validation_last_event_timestamp: refMarkDetail.event_timestamp
        }
      }
      return markConfig;
    }

    // In line function to format markConfig based on lookup data
    const formatUnlinkedMarkConfig = (markConfig) => {
      // ---------------------------------
      if (typeof markConfig.mark_id === 'undefined') {
        return {
          ...markConfig,
          mark_id: null,
          validation_prefix_number: null,
          validation_short_number: null,
          validation_state: null,
          validation_bander_id: null
        }
      }
      return markConfig;
    }

    lookupData.markConfiguration.map(refMarkDetail => {
      // For each mark configuration looked up, supplement the event mark configuration
      response.map(record => {
        // MARK CONFIGURATION
        record.mark_configuration = record.mark_configuration.map(markConfig => {
          // For each capture markConfig, add supplementary information
          return formatMarkConfig(markConfig, refMarkDetail);
        });
      });
    });

    response.map(record => {
      // POPULATE UNLINKED MARK CONFIGURATION
      record.mark_configuration = record.mark_configuration.map(markConfig => {
        return formatUnlinkedMarkConfig(markConfig);
      });
    });

    // If we have bird data at this point, return with the validation to assist in the UI
    if (lookupData.bird) {
      response.map(record => {
        let birdSearch = lookupData.bird.find(birdDetail => {
          return (
            typeof record.mark_configuration.find(markConfig => {
              return (markConfig.alphanumeric_text
                && markConfig.alphanumeric_text.toLowerCase() === `${birdDetail.prefix_number}-${birdDetail.short_number}`);
            }) !== 'undefined'
          );
        });

        let possibleBirdIds = [...new Set(lookupData.bird.filter(birdDetail => {
          return (
            typeof record.mark_configuration.find(markConfig => {
              return (markConfig.alphanumeric_text
                && markConfig.alphanumeric_text.toLowerCase() === `${birdDetail.prefix_number}-${birdDetail.short_number}`);
            }) !== 'undefined'
          );
        }).map(birdDetail => birdDetail.id))];
        console.log(`Possible bird-ids: ${possibleBirdIds}`);
        console.log(`Number of unique bird associations possible: ${possibleBirdIds.length}`);
        record.bird.bird_association_length = possibleBirdIds.length;

        // IF WE'VE FOUND A BIRD TO LINK TO, UPDATE THE SPECIES CODE AND BIRD-ID TO ASSIST THE UI
        if (typeof birdSearch !== 'undefined') {
          record.bird.id = birdSearch.id;
          record.bird.species_id = (record.bird.id) ? record.bird.species_id : birdSearch.species_id;
          record.bird.validation_id = null;
          record.bird.validation_species_id = birdSearch.species_id;
          record.bird.validation_species_common_name = birdSearch.common_name_nznbbs;
          record.bird.validation_valid_band_prefixes = birdSearch.valid_band_prefixes;
          record.bird.validation_first_marking_timestamp = ('vw_birds_to_first_marking_date' in birdSearch) ? birdSearch.vw_birds_to_first_marking_date.first_marking_timestamp : null;
          record.bird.validation_first_marking_id = ('vw_birds_to_first_marking_date' in birdSearch) ? birdSearch.vw_birds_to_first_marking_date.event_id : null;
          record.bird.validation_earliest_death_resighting = ('vw_birds_earliest_death_resighting' in birdSearch && birdSearch.vw_birds_earliest_death_resighting) ? birdSearch.vw_birds_earliest_death_resighting.earliest_dead_timestamp : null;
          record.bird.validation_latest_alive_resighting = ('vw_birds_latest_alive_resighting' in birdSearch && birdSearch.vw_birds_latest_alive_resighting) ? birdSearch.vw_birds_latest_alive_resighting.latest_alive_timestamp : null;
        }
        else if (record.event.event_type === 'IN_HAND_POST_CHANGE'
                  && typeof response.find(searchRecord => searchRecord.metadata.eventIndex === record.metadata.eventIndex 
                                                    && searchRecord.event.event_type === 'IN_HAND_PRE_CHANGE'
                                                    && 'id' in searchRecord.bird) !== 'undefined') {
          // If a post change event link bird to pre change (note prechange will have been processed just prior)
          console.info(`Prechange event linking to postchange event`);
          let searchRecord = response.find(searchRecord => searchRecord.metadata.eventIndex === record.metadata.eventIndex 
                                                            && searchRecord.event.event_type === 'IN_HAND_PRE_CHANGE'
                                                            && 'id' in searchRecord.bird);
          record.bird.id = searchRecord.bird.id;
          record.bird.species_id = searchRecord.bird.species_id;
          record.bird.validation_id = searchRecord.bird.validation_id;
          record.bird.validation_species_id = searchRecord.bird.validation_species_id;
          record.bird.validation_species_common_name = searchRecord.bird.validation_species_common_name;
          record.bird.validation_valid_band_prefixes = searchRecord.bird.validation_valid_band_prefixes;
          record.bird.validation_first_marking_timestamp = searchRecord.bird.validation_first_marking_timestamp;
          record.bird.validation_first_marking_id = searchRecord.bird.validation_first_marking_id;
          record.bird.validation_earliest_death_resighting = searchRecord.bird.validation_earliest_death_resighting;
          record.bird.validation_latest_alive_resighting = searchRecord.bird.validation_latest_alive_resighting;
        }
      })
    }
  }

  // -----------------------------------------
  // GET DATA RELATED TO THE CHARACTERISTIC_MEASUREMENTS
  // -----------------------------------------
  if (validations.includes('characteristicMeasurement')) {

    response.map(record => {
      // ------------------------------------
      record.characteristic_measurement = record.characteristic_measurement.map(recordCharMeasure => {
        let characteristicSearch = lookupData.characteristicMeasurement.find(charDetail => {
          return recordCharMeasure.raw_characteristic_name && recordCharMeasure.raw_characteristic_name === charDetail.ss_source_name_;
        });

        let otherCharacteristicSearch = lookupData.characteristicMeasurement.find(charDetail => {
          return charDetail.ss_source_name_ === 'otherdetail';
        });

        recordCharMeasure.characteristic_id = (typeof characteristicSearch !== 'undefined') ? characteristicSearch.id : otherCharacteristicSearch.id;
        recordCharMeasure.value = (typeof characteristicSearch !== 'undefined') ? recordCharMeasure.raw_value : `${recordCharMeasure.raw_characteristic_name}: ${recordCharMeasure.raw_value}`;
        recordCharMeasure.validation_characteristic_unit = (typeof characteristicSearch !== 'undefined') ? characteristicSearch.unit : null;
        return recordCharMeasure;
      });
    })
  }

  // -----------------------------------------
  // SUPPLEMENT DATA RELATED TO THE EXISTING BIRD (IF KNOWN)
  // -----------------------------------------
  if (validations.includes('bird') && lookupData.species) {
    console.log('Lookup species: ', lookupData.species);

    response.map(record => {
      // ------------------------------------
      let speciesSearch = lookupData.species.find(speciesDetail => {
        return record.bird.raw_species_code_nznbbs && record.bird.raw_species_code_nznbbs === speciesDetail.species_code_nznbbs;
      });

      record.bird.species_common_name = (typeof speciesSearch !== 'undefined') ? speciesSearch.common_name_nznbbs : null;
      record.bird.species_id = ((typeof record.bird.species_id === 'undefined' || !record.bird.species_id) && typeof speciesSearch !== 'undefined') ? speciesSearch.id : null;
      record.bird.validation_valid_band_prefixes = (typeof speciesSearch !== 'undefined') ? speciesSearch.valid_band_prefixes : null;
    })
  }

  // -----------------------------------------
  // SUPPLEMENT DATA RELATED TO THE BANDERS (IF KNOWN)
  // -----------------------------------------
  if (validations.includes('bander') && lookupData.bander) {
    // PlACEHOLDER, CURRENTLY NO BANDER VALIDATION REQUIRED
    console.log('Lookup banders: ', lookupData.bander);
    // ------------------------------------
    response.map(record => {
      // ------------------------------------
      let reporterSearch = lookupData.bander.find(banderDetail => {
        return record.event.raw_event_reporter_nznbbs_certification_number && record.event.raw_event_reporter_nznbbs_certification_number === banderDetail.nznbbs_certification_number;
      });

      let providerSearch = lookupData.bander.find(banderDetail => {
        return record.event.raw_event_provider_nznbbs_certification_number && record.event.raw_event_provider_nznbbs_certification_number === banderDetail.nznbbs_certification_number;
      });

      record.event.event_reporter_id = (typeof reporterSearch !== 'undefined') ? reporterSearch.bander_id : null;
      record.event.event_provider_id = (typeof providerSearch !== 'undefined') ? providerSearch.bander_id : null;
    });
  }

  // -----------------------------------------
  // SUPPLEMENT DATA RELATED TO LOCATION (IF KNOWN)
  // -----------------------------------------
  if (validations.includes('location') && lookupData.location) {
    // PlACEHOLDER, CURRENTLY NO LOOKUP DATA REQUIRED
  }

  console.log(response);
  console.log(JSON.stringify(response));
  return response;
}


const validatePostBusinessRules = async (customErrorFactory, claims, governingCognitoGroup, validations, data) => {
  // ------------------------------------------
  console.info('Validating post business rules');

  let errors = [];

  // -----------------------------------------
  // VALIDATE DATA RELATED TO EVENT (IF KNOWN)
  // -----------------------------------------
  if (validations.includes('event')) {
    // -----------------------------------
    data.map((record, idx) => {
      let event = record.event;
      // 1) For bird in-hand events, capture_type is required where wild captive not release site or captivity
      if ('event_type' in event
        && 'event_capture_type' in event
        && event.event_type.includes('IN_HAND')
        && ['WILD', 'SOURCE_SITE'].includes(event.event_bird_situation)
        && !event.event_capture_type) {
        // ------------------------------------
        errors.push(customErrorFactory.getError('RelatedPropertyRequired', [`For event_type: ${event.event_type}`, null, `/${idx}/event/event_capture_type`, 'event_capture_type']));
      }

      // 2) Validate top-level characteristic_measurements (OUT_STATUS_CODE - , OUT_CONDITION_CODE)
      record.characteristic_measurement.map((charMeasure, innerIdx) => {
        if (charMeasure.characteristic_id === 43 && !ALLOWABLE_STATUS_CODES.includes(charMeasure.value)) {
          errors.push(customErrorFactory.getError('PropertyEnumError', [`Status Code`, charMeasure.value, `/${idx}/characteristic_measurement/${innerIdx}`, ALLOWABLE_STATUS_CODES]));
        }
        if (charMeasure.characteristic_id === 44 && !ALLOWABLE_CONDITION_CODES.includes(charMeasure.value)) {
          errors.push(customErrorFactory.getError('PropertyEnumError', [`Condition Code`, charMeasure.value, `${idx}/characteristic_measurement/${innerIdx}`, ALLOWABLE_CONDITION_CODES]));
        }
      });
    });


  }

  // -----------------------------------------
  // VALIDATE DATA RELATED TO THE MARK_CONFIGURATION<->EVENT (IF KNOWN)
  // -----------------------------------------
  if (validations.includes('markConfiguration')) {
    // ----------------------------------------------------

    data.map((record, idx) => {
      // -----------------------------------
      // For each event, complete validation of the mark_configuration

      // 1) Validate that at least 1 mark is provided in the mark_configuration_release (should hold true for all cases EXCEPT REMARKING)
      //  -- Updated to allow empty release configuration for remarking events (i.e. birds where all bands are removed - must have mark configuration capture)
      if (!(record.mark_configuration_capture.length > 0)
        && record.mark_configuration_release.length === 0) {
        errors.push(customErrorFactory.getError('InvalidEmptyListProperty', [`mark_configuration_release`, '[]', `/${idx}/mark_configuration_release`]));
      }

      // 2) Validate that if mark_configuration_capture should/should not be submitted (should hold true for all cases)
      if (['FIRST_MARKING_IN_HAND', 'SIGHTING_BY_PERSON', 'RECORDED_BY_TECHNOLOGY'].includes(record.event.event_type)
        && record.mark_configuration_capture.length > 0) {
        errors.push(customErrorFactory.getError('InvalidListProperty', [`mark_configuration_capture`, JSON.stringify(record.mark_configuration_capture), `/${idx}/mark_configuration_capture`, `for event_type ${record.event.event_type}`]));
      }

      // 3) Validate that the mark state is valid for the event_type
      record.mark_configuration_capture.map((markConfig, innerIdx) => {
        // ---------------------------------------
        if (markConfig.validation_state && !['ATTACHED'].includes(markConfig.validation_state)) {
          errors.push(customErrorFactory.getError('MarkStateLifecycleError', ['Marks should be ATTACHED before being observed at capture', 'This can happen when results are submitted out of chronological order', markConfig.validation_state, `/${idx}/mark_configuration_capture/${innerIdx}`, 'WARNING']));
        }
      });

      // 4) Validate event_type/mark_state relationships
      record.mark_configuration_release.map((markConfig, innerIdx) => {
        // ---------------------------------------
        // For first marking, marks must be in the 'AlLOCATED' state
        if (markConfig.mark_id && ['FIRST_MARKING_IN_HAND'].includes(record.event.event_type) && markConfig.validation_state && !['ALLOCATED'].includes(markConfig.validation_state)) {
          // --------------------------------------------------
          errors.push(customErrorFactory.getError('MarkStateLifecycleError', ['Marks should be ALLOCATED before being used as release marks for FIRST_MARKING_IN_HAND', 'This can happen when results are submitted out of order', markConfig.validation_state, `/${idx}/mark_configuration_release/${innerIdx}`, 'WARNING']));
        }
        // For in hand events, marks must be in the 'AlLOCATED' or 'ATTACHED' state
        if (markConfig.mark_id && ['IN_HAND'].includes(record.event.event_type) && markConfig.validation_state && !['ALLOCATED', 'ATTACHED'].includes(markConfig.validation_state)) {
          errors.push(customErrorFactory.getError('MarkStateLifecycleError', ['Marks should be ALLOCATED or ATTACHED before being used a release marks for IN_HAND', 'This can happen when results are submitted out of chronological order', markConfig.validation_state, `/${idx}/mark_configuration_release/${innerIdx}`, 'WARNING']));
        }
        // For resighting by person or recorded by technology events, marks must be in the ATTACHED' state
        if (markConfig.mark_id && ['SIGHTING_BY_PERSON', 'RECORDED_BY_TECHNOLOGY'].includes(record.event.event_type) && markConfig.validation_state && !['ATTACHED'].includes(markConfig.validation_state)) {
          errors.push(customErrorFactory.getError('MarkStateLifecycleError', ['Marks should be ATTACHED before being SIGHTED_BY_PERSON or RECORDED_BY_TECHNOLOGY', 'This can happen when results are submitted out of chronological order', markConfig.validation_state, `/${idx}/mark_configuration_release/${innerIdx}`, 'WARNING']));
        }
      });

      // 5) Validate that there is at least one association to known stock items, if not warn the user
      if ([
        ...record.mark_configuration_capture.filter(markConfig => markConfig.mark_id),
        ...record.mark_configuration_release.filter(markConfig => markConfig.mark_id)
      ].length === 0) {
        let alphanumericTextValues = [
          ...record.mark_configuration_capture.filter(markConfig => markConfig.alphanumeric_text).map(markConfig => markConfig.alphanumeric_text),
          ...record.mark_configuration_release.filter(markConfig => markConfig.alphanumeric_text).map(markConfig => markConfig.alphanumeric_text)
        ]
        alphanumericTextValues = (alphanumericTextValues.length === 0) ? ['No alphanumerics'] : alphanumericTextValues;
        errors.push(customErrorFactory.getError('NoStockAssociationPossible', [alphanumericTextValues.join(', '), `/${idx}/mark_configuration_capture,/${idx}/mark_configuration_release`, alphanumericTextValues.join(', ')]));
      }
    });
  }

  // -----------------------------------------
  // VALIDATE DATA RELATED TO THE EXISTING BIRD (IF KNOWN)
  // -----------------------------------------
  if (validations.includes('bird')) {
    // -----------------------------------------------
    data.map((record, idx) => {
      // ----------------------------------------
      // 1a) If the record is a first_marking_in_hand event, there should not be an existing first marking event
      if (record.event.event_type === 'FIRST_MARKING_IN_HAND'
        && 'validation_first_marking_timestamp' in record.bird
        && record.bird.validation_first_marking_timestamp) {
        errors.push(customErrorFactory.getError('BirdAlreadyHasFirstMarkingError', [`${process.env.APPLICATION_DOMAIN}/view-data/bird/${record.bird.id}`, MomentTimezone(record.bird.validation_first_marking_timestamp).tz('NZ').format('DD/MM/YYYY hh:mm:ss A'), record.event.event_type, `/${idx}/event/event_type`]));
      }

      // 1b) If the record is a first_marking_in_hand event, there should not be any resightings before it
      //        -> CRITICAL unless the event_bird_situation is 'SOURCE_SITE' or 'CAPTIVE'
      if (record.event.event_type === 'FIRST_MARKING_IN_HAND'
        && 'validation_earliest_resighting_timestamp' in record.bird
        && record.bird.validation_earliest_resighting_timestamp
        && Moment(record.event.event_timestamp).isAfter(Moment(record.bird.validation_earliest_resighting_timestamp))) {
          errors.push(customErrorFactory.getError('SightingBeforeFirstMarkingError', [`${process.env.APPLICATION_DOMAIN}/view-data/bird/${record.bird.id}`, MomentTimezone(record.bird.validation_earliest_resighting_timestamp).tz('NZ').format('DD/MM/YYYY hh:mm:ss A'), MomentTimezone(record.event.event_timestamp).tz('NZ').format('DD/MM/YYYY hh:mm:ss A'), `/${idx}/event/event_timestamp`, 'CRITICAL']));
      }

      // 1c) If the record is not a first_marking_in_hand event, it should not be before the first_marking event if it exists
      if (record.event.event_type !== 'FIRST_MARKING_IN_HAND'
        && 'validation_first_marking_timestamp' in record.bird
        && record.bird.validation_first_marking_timestamp
        && Moment(record.event.event_timestamp).isBefore(Moment(record.bird.validation_first_marking_timestamp))) {
          let severity = (['SOURCE_SITE', 'CAPTIVE'].includes(record.event.event_bird_situation)) ? 'WARNING' : 'CRITICAL';
          errors.push(customErrorFactory.getError('SightingBeforeFirstMarkingError', [`${process.env.APPLICATION_DOMAIN}/view-data/bird/${record.bird.id}`, MomentTimezone(record.event.event_timestamp).tz('NZ').format('DD/MM/YYYY hh:mm:ss A'), MomentTimezone(record.bird.validation_first_marking_timestamp).tz('NZ').format('DD/MM/YYYY hh:mm:ss A'), `/${idx}/event/event_timestamp`, severity]));
      }

      // 2) If any DOC stock is involved, we should validate that a correct prefix size has been used
      if ('validation_valid_band_prefixes' in record.bird
        && record.bird.validation_valid_band_prefixes) {
        // ------------------------------------------------------
        record.mark_configuration_capture.map((markConfig, innerIdx) => {
          if ('mark_id' in markConfig
            && markConfig.mark_id
            && 'validation_prefix_number' in markConfig
            && markConfig.validation_prefix_number
            && record.bird.validation_valid_band_prefixes
            && !record.bird.validation_valid_band_prefixes.replace(/ /g, '').split(',').includes(markConfig.validation_prefix_number)) {
            errors.push(customErrorFactory.getError('UnexpectedSpeciesBandPrefix', [markConfig.validation_prefix_number, record.bird.species_common_name, markConfig.validation_prefix_number, `/${idx}/mark_configuration_capture/${innerIdx}/alphanumeric_text`, record.bird.validation_valid_band_prefixes]));
          }
        });

        record.mark_configuration_release.map((markConfig, innerIdx) => {
          if ('mark_id' in markConfig
            && markConfig.mark_id
            && 'validation_prefix_number' in markConfig
            && markConfig.validation_prefix_number
            && record.bird.validation_valid_band_prefixes
            && !record.bird.validation_valid_band_prefixes.replace(/ /g, '').split(',').includes(markConfig.validation_prefix_number)) {
            errors.push(customErrorFactory.getError('UnexpectedSpeciesBandPrefix', [markConfig.validation_prefix_number, record.bird.species_common_name, markConfig.validation_prefix_number, `/${idx}/mark_configuration_release/${innerIdx}/alphanumeric_text`, record.bird.validation_valid_band_prefixes]));
          }
        });
      }

      // 3) If a bird exists in the system then the species definition should match the existing definition
      if ('validation_species_id' in record.bird
        && record.bird.validation_species_id
        && record.bird.species_id !== record.bird.validation_species_id) {
        errors.push(customErrorFactory.getError('BirdSpeciesConflictError', [`${process.env.APPLICATION_DOMAIN}/view-data/bird/${record.bird.id}`, record.bird.validation_species_common_name, record.bird.species_common_name, `/${idx}/bird/species_id`, 'CRITICAL']));
      }

      // 4) If the record is not a first_marking_in_hand event, and a first marking event doesn't exist warn the user
      if (record.event.event_type !== 'FIRST_MARKING_IN_HAND'
        && (!record.bird.id
          || !('validation_first_marking_timestamp' in record.bird)
          || !record.bird.validation_first_marking_timestamp)) {
        let allMarks = [
          ...record.mark_configuration_capture.filter(markConfig => markConfig.alphanumeric_text).map(markConfig => markConfig.alphanumeric_text),
          ...record.mark_configuration_release.filter(markConfig => markConfig.alphanumeric_text).map(markConfig => markConfig.alphanumeric_text)
        ].join(', ');
        errors.push(customErrorFactory.getError('BirdMissingFirstMarking', [null, null, allMarks, `/${idx}/mark_configuration_capture,/${idx}/mark_configuration_release`]));
      }

      record.characteristic_measurement.map((charMeasure, innerIdx) => {
        // 5) Validate that the bird is not being reported dead before it has been recorded as alive
        if (charMeasure.characteristic_id === 43
          && charMeasure.value
          && ('' + charMeasure.value).includes('DEAD')
          && 'validation_latest_alive_resighting' in record.bird
          && record.bird.validation_latest_alive_resighting
          && Moment(record.event.event_timestamp).isBefore(Moment(record.bird.validation_latest_alive_resighting))) {
          errors.push(customErrorFactory.getError('InvalidStatusCode', [charMeasure.value, 'ALIVE', charMeasure.value, `/${idx}/characteristic_measurement/${innerIdx}`, MomentTimezone(record.event.event_timestamp).tz('NZ').format('DD/MM/YYYY hh:mm:ss A'), MomentTimezone(record.bird.validation_latest_alive_resighting).tz('NZ').format('DD/MM/YYYY hh:mm:ss A')]));
        }
        // 6) Validate that the bird is not being reported alive after it has been recorded as dead
        if (charMeasure.characteristic_id === 43
          && charMeasure.value
          && ('' + charMeasure.value).includes('ALIVE')
          && 'validation_earliest_death_resighting' in record.bird
          && record.bird.validation_earliest_death_resighting
          && Moment(record.event.event_timestamp).isAfter(Moment(record.bird.validation_earliest_death_resighting))) {
          errors.push(customErrorFactory.getError('InvalidStatusCode', ['DEAD', charMeasure.value, charMeasure.value, `/${idx}/characteristic_measurement/${innerIdx}`, MomentTimezone(record.bird.validation_earliest_death_resighting).tz('NZ').format('DD/MM/YYYY hh:mm:ss A'), MomentTimezone(record.event.event_timestamp).tz('NZ').format('DD/MM/YYYY hh:mm:ss A')]));
        }
      });

      // 9) Send a warning when the bird is reported as DEAD previously in it's timeline
      if ('validation_earliest_death_resighting' in record.bird
        && record.bird.validation_earliest_death_resighting) {
        // --------------------------------------------------------
        errors.push(customErrorFactory.getError('BirdStatusDeadWarning', [record.bird.id, `/${idx}/bird/id,/${idx}/mark_configuration`]));
      }

      // 10) Capture critical error when multiple bird associations are possible as part of a record
      if ('bird_association_length' in record.bird
        && record.bird.bird_association_length
        && record.bird.bird_association_length > 1) {
        // --------------------------------------------------------
        let bandNumbers = [
          ...record.mark_configuration_capture.filter(markConfig => markConfig.mark_id).map(markConfig => markConfig.alphanumeric_text),
          ...record.mark_configuration_release.filter(markConfig => markConfig.mark_id).map(markConfig => markConfig.alphanumeric_text)
        ];
        errors.push(customErrorFactory.getError('MultipleBirdAssociationsPossible', [record.mark_configuration, `/${idx}/mark_configuration`, record.bird.bird_association_length, bandNumbers]));
      }
    });
  }
  // -----------------------------------------
  // VALIDATE DATA RELATED TO THE BANDERS (IF KNOWN)
  // -----------------------------------------
  if (validations.includes('bander')) {

  }

  // -----------------------------------------
  // VALIDATE DATA RELATED TO LOCATION (IF KNOWN)
  // -----------------------------------------
  if (validations.includes('location')) {
    // -----------------------------------
    const MIN_NORTHING_NZTM = 4600000;
    const MAX_NORTHING_NZTM = 6300000;
    const MIN_EASTING_NZTM = 1000000;
    const MAX_EASTING_NZTM = 2200000;
    const MIN_NORTHING_NZMG = 5200000;
    const MAX_NORTHING_NZMG = 6900000;
    const MIN_EASTING_NZMG = 1900000;
    const MAX_EASTING_NZMG = 3100000;

    data.map((record, idx) => {
      // 1) Validate user northing and easting if provided with NZTM coordinate system
      if (record.event.user_coordinate_system === 'NZTM'
        && record.event.user_easting
        && ((record.event.user_easting < MIN_EASTING_NZTM || record.event.user_easting > MAX_EASTING_NZTM)
          || (record.event.user_northing < MIN_NORTHING_NZTM || record.event.user_northing > MAX_NORTHING_NZTM))) {
        errors.push(customErrorFactory.getError('InvalidProjectedCoordinate',
          [
            record.event.user_coordinate_system,
            MIN_EASTING_NZTM,
            `${record.event.user_coordinate_system}, ${record.event.user_easting}mE, ${record.event.user_northing}mN`,
            `/${idx}/event/user_coordinate_system,/${idx}/event/user_easting,/${idx}/event/user_northing`,
            MAX_EASTING_NZTM,
            MIN_NORTHING_NZTM,
            MAX_NORTHING_NZTM
          ]));
      }

      // 2) Validate user northing and easting if provided with NZMG coordinate system
      if (record.event.user_coordinate_system === 'NZMG'
        && record.event.user_easting
        && ((record.event.user_easting < MIN_EASTING_NZMG || record.event.user_easting > MAX_EASTING_NZMG)
          || (record.event.user_northing < MIN_NORTHING_NZMG || record.event.user_northing > MAX_NORTHING_NZMG))) {
        errors.push(customErrorFactory.getError('InvalidProjectedCoordinate',
          [
            record.event.user_coordinate_system,
            MIN_EASTING_NZMG,
            `${record.event.user_coordinate_system}, ${record.event.user_easting}mE, ${record.event.user_northing}mN`,
            `/${idx}/event/user_coordinate_system,/${idx}/event/user_easting,/${idx}/event/user_northing`,
            MAX_EASTING_NZMG,
            MIN_NORTHING_NZMG,
            MAX_NORTHING_NZMG
          ]));
      }

    });
  }

  console.log(errors);
  return errors;
}


const validatePutBusinessRules = async (customErrorFactory, claims, governingCognitoGroup, validations, data, current) => {
  // ------------------------------------------
  console.info('Validating put business rules');

  let errors = [];

  // -----------------------------------------
  // VALIDATE DATA RELATED TO EVENT (IF KNOWN)
  // -----------------------------------------
  if (validations.includes('event')) {
    // -----------------------------------
    data.map((record, idx) => {
      let event = record.event;
      // 1) For bird in-hand events, capture_type is required where wild captive not release site or captivity
      if ('event_type' in event
        && 'event_capture_type' in event
        && event.event_type.includes('IN_HAND')
        && ['WILD', 'SOURCE_SITE'].includes(event.event_bird_situation)
        && !event.event_capture_type) {
        // ------------------------------------
        errors.push(customErrorFactory.getError('RelatedPropertyRequired', [`For event_type: ${event.event_type}`, null, `/${idx}/event/event_capture_type`, 'event_capture_type']));
      }

      // 2) Validate top-level characteristic_measurements (OUT_STATUS_CODE - , OUT_CONDITION_CODE)
      record.characteristic_measurement.map((charMeasure, innerIdx) => {
        if (charMeasure.characteristic_id === 43 && !ALLOWABLE_STATUS_CODES.includes(charMeasure.value)) {
          errors.push(customErrorFactory.getError('PropertyEnumError', [`Status Code`, charMeasure.value, `/${idx}/characteristic_measurement/${innerIdx}`, ALLOWABLE_STATUS_CODES]));
        }
        if (charMeasure.characteristic_id === 44 && !ALLOWABLE_CONDITION_CODES.includes(charMeasure.value)) {
          errors.push(customErrorFactory.getError('PropertyEnumError', [`Condition Code`, charMeasure.value, `${idx}/characteristic_measurement/${innerIdx}`, ALLOWABLE_CONDITION_CODES]));
        }
      });
    });
  }

  // -----------------------------------------
  // VALIDATE DATA RELATED TO THE MARK_CONFIGURATION<->EVENT (IF KNOWN)
  // -----------------------------------------
  if (validations.includes('markConfiguration')) {
    // ----------------------------------------------------

    data.map((record, idx) => {
      // -----------------------------------
      // For each event, complete validation of the mark_configuration

      // 1) Validate that at least 1 mark is provided in the mark_configuration (should hold true for all cases of edits)
      if (record.mark_configuration.length === 0) {
        errors.push(customErrorFactory.getError('InvalidEmptyListProperty', [`mark_configuration`, '[]', `/${idx}/mark_configuration`]));
      }

      // 2) [NOT REQUIRED] Validation of mark_configuration not required for updates as events are split

      // 3) Validate that the mark state is valid for the event_type
      record.mark_configuration.map((markConfig, innerIdx) => {
        // ---------------------------------------
        // For first marking, marks must be in the 'AlLOCATED' state
        if (markConfig.mark_id && ['FIRST_MARKING_IN_HAND'].includes(record.event.event_type) && markConfig.validation_state && !['ALLOCATED'].includes(markConfig.validation_state)) {
          // --------------------------------------------------
          errors.push(customErrorFactory.getError('MarkStateLifecycleError', ['Marks should be ALLOCATED before being used as release marks for FIRST_MARKING_IN_HAND', 'This can happen when results are submitted out of order', markConfig.validation_state, `/${idx}/mark_configuration/${innerIdx}`, 'WARNING']));
        }
        if (markConfig.mark_id && ['IN_HAND', 'IN_HAND_POST_CHANGE'].includes(record.event.event_type) && markConfig.validation_state && !['ALLOCATED', 'ATTACHED'].includes(markConfig.validation_state)) {
          errors.push(customErrorFactory.getError('MarkStateLifecycleError', ['Marks should be ALLOCATED or ATTACHED before being used a release marks for IN_HAND or IN_HAND_POST_CHANGE', 'This can happen when results are submitted out of chronological order', markConfig.validation_state, `/${idx}/mark_configuration/${innerIdx}`, 'WARNING']));
        }
        if (markConfig.mark_id && ['IN_HAND_PRE_CHANGE', 'SIGHTING_BY_PERSON', 'RECORDED_BY_TECHNOLOGY'].includes(record.event.event_type) && markConfig.validation_state && !['ATTACHED'].includes(markConfig.validation_state)) {
          errors.push(customErrorFactory.getError('MarkStateLifecycleError', ['Marks should be ATTACHED before being IN_HAND_PRE_CHANGE, RESIGHTED_BY_PERSON or RECORDED_BY_TECHNOLOGY', 'This can happen when results are submitted out of chronological order', markConfig.validation_state, `/${idx}/mark_configuration/${innerIdx}`, 'WARNING']));
        }
      });

      // 4) Validate that there is at least one association to known stock items, if not warn the user
      if (record.mark_configuration.filter(markConfig => markConfig.mark_id).length === 0) {
        let alphanumericTextValues = record.mark_configuration.filter(markConfig => markConfig.alphanumeric_text).map(markConfig => markConfig.alphanumeric_text);
        alphanumericTextValues = (alphanumericTextValues.length === 0) ? ['No alphanumerics'] : alphanumericTextValues;
        errors.push(customErrorFactory.getError('NoStockAssociationPossible', [alphanumericTextValues.join(', '), `/${idx}/mark_configuration_capture,/${idx}/mark_configuration_release`, alphanumericTextValues.join(', ')]));
      }
    });
  }

  // -----------------------------------------
  // VALIDATE DATA RELATED TO THE EXISTING BIRD (IF KNOWN)
  // -----------------------------------------
  if (validations.includes('bird')) {
    // -----------------------------------------------
    data.map((record, idx) => {
      // ----------------------------------------
      // 1a) If the record is a first_marking_in_hand event, there should not be an existing first marking event
      //      UNLESS WE ARE UPDATING THE ORIGINAL FIRST MARKING EVENT
      if (record.event.event_type === 'FIRST_MARKING_IN_HAND'
        && 'validation_first_marking_timestamp' in record.bird
        && record.bird.validation_first_marking_timestamp
        && record.event.id !== record.bird.validation_first_marking_timestamp
        && current[0].id !== record.bird.validation_first_marking_id) {
        errors.push(customErrorFactory.getError('BirdAlreadyHasFirstMarkingError', [`${process.env.APPLICATION_DOMAIN}/view-data/bird/${record.bird.id}`, MomentTimezone(record.bird.validation_first_marking_timestamp).tz('NZ').format('DD/MM/YYYY hh:mm:ss A'), record.event.event_type, `/${idx}/event/event_type`]));
      }

      // 1b) If the record is a first_marking_in_hand event, there should not be any resightings before it
      if (record.event.event_type === 'FIRST_MARKING_IN_HAND'
        && 'validation_earliest_resighting_timestamp' in record.bird
        && record.bird.validation_earliest_resighting_timestamp
        && Moment(record.event.event_timestamp).isAfter(Moment(record.bird.validation_earliest_resighting_timestamp))) {
        errors.push(customErrorFactory.getError('SightingBeforeFirstMarkingError', [`${process.env.APPLICATION_DOMAIN}/view-data/bird/${record.bird.id}`, MomentTimezone(record.bird.validation_earliest_resighting_timestamp).tz('NZ').format('DD/MM/YYYY hh:mm:ss A'), MomentTimezone(record.event.event_timestamp).tz('NZ').format('DD/MM/YYYY hh:mm:ss A'), `/${idx}/event/event_timestamp`, 'CRITICAL']));
      }

      // 1c) If the record is not a first_marking_in_hand event, it should not be before the first_marking event if it exists
      if (record.event.event_type !== 'FIRST_MARKING_IN_HAND'
        && 'validation_first_marking_timestamp' in record.bird
        && record.bird.validation_first_marking_timestamp
        && Moment(record.event.event_timestamp).isBefore(Moment(record.bird.validation_first_marking_timestamp))) {
          let severity = (['SOURCE_SITE', 'CAPTIVE'].includes(record.event.event_bird_situation)) ? 'WARNING' : 'CRITICAL';
          errors.push(customErrorFactory.getError('SightingBeforeFirstMarkingError', [`${process.env.APPLICATION_DOMAIN}/view-data/bird/${record.bird.id}`, MomentTimezone(record.event.event_timestamp).tz('NZ').format('DD/MM/YYYY hh:mm:ss A'), MomentTimezone(record.bird.validation_first_marking_timestamp).tz('NZ').format('DD/MM/YYYY hh:mm:ss A'), `/${idx}/event/event_timestamp`, severity]));
      }

      // 2) If any DOC stock is involved, we should validate that a correct prefix size has been used
      if ('validation_valid_band_prefixes' in record.bird
        && record.bird.validation_valid_band_prefixes) {
        // ------------------------------------------------------
        record.mark_configuration.map((markConfig, innerIdx) => {
          if ('mark_id' in markConfig
            && markConfig.mark_id
            && 'validation_prefix_number' in markConfig
            && markConfig.validation_prefix_number
            && record.bird.validation_valid_band_prefixes
            && !record.bird.validation_valid_band_prefixes.replace(/ /g, '').split(',').includes(markConfig.validation_prefix_number)) {
            errors.push(customErrorFactory.getError('UnexpectedSpeciesBandPrefix', [markConfig.validation_prefix_number, record.bird.validation_species_common_name, markConfig.validation_prefix_number, `/${idx}/mark_configuration/${innerIdx}/alphanumeric_text`, record.bird.validation_valid_band_prefixes]));
          }
        });
      }

      // 3) If a bird exists in the system then the species definition should match the existing definition
      if ('validation_species_id' in record.bird
        && record.bird.validation_species_id
        && record.bird.species_id !== record.bird.validation_species_id) {
        errors.push(customErrorFactory.getError('BirdSpeciesConflictError', [`${process.env.APPLICATION_DOMAIN}/view-data/bird/${record.bird.id}`, record.bird.validation_species_common_name, record.bird.species_common_name, `/${idx}/bird/species_id`, 'WARNING']));
      }

      // 4) If the record is not a first_marking_in_hand event, and a first marking event doesn't exist warn the user
      if (record.event.event_type !== 'FIRST_MARKING_IN_HAND'
        && (!record.bird.id
          || !('validation_first_marking_timestamp' in record.bird)
          || !record.bird.validation_first_marking_timestamp)) {
        let allMarks = [
          ...record.mark_configuration.filter(markConfig => markConfig.alphanumeric_text).map(markConfig => markConfig.alphanumeric_text),
        ].join(', ');
        errors.push(customErrorFactory.getError('BirdMissingFirstMarking', [null, null, allMarks, `/${idx}/mark_configuration,/${idx}/mark_configuration`]));
      }


      // 7) If the bird_id is going to change, send a warning to the user that this is the case
      if ('validation_id' in record.bird
        && record.bird.validation_id
        && record.bird.id !== record.bird.validation_id) {
        errors.push(customErrorFactory.getError('WarningBirdAssociationChange', [record.bird.validation_id, record.bird.id, record.bird.id, `/${idx}/bird/id,/${idx}/mark_configuration`, process.env.APPLICATION_DOMAIN]));
      }

      // 8) If a bird-id update is requested the bird-id must exist
      if ('validation_id_exists' in record.bird
        && !record.bird.validation_id_exists) {
        errors.push(customErrorFactory.getError('BirdIdDoesNotExist', [record.bird.id, record.bird.id, `/${idx}/bird/id`]));
      }


      record.characteristic_measurement.map((charMeasure, innerIdx) => {
        // 5) Validate that the bird is not being reported dead before it has been recorded as alive
        if (charMeasure.characteristic_id === 43
          && charMeasure.value
          && ('' + charMeasure.value).includes('DEAD')
          && 'validation_latest_alive_resighting' in record.bird
          && record.bird.validation_latest_alive_resighting
          && Moment(record.event.event_timestamp).isBefore(Moment(record.bird.validation_latest_alive_resighting))) {
          errors.push(customErrorFactory.getError('InvalidStatusCode', [charMeasure.value, 'ALIVE', charMeasure.value, `/${idx}/characteristic_measurement/${innerIdx}`, MomentTimezone(record.event.event_timestamp).tz('NZ').format('DD/MM/YYYY hh:mm:ss A'), MomentTimezone(record.bird.validation_latest_alive_resighting).tz('NZ').format('DD/MM/YYYY hh:mm:ss A')]));
        }
        // 6) Validate that the bird is not being reported alive after it has been recorded as dead
        if (charMeasure.characteristic_id === 43
          && charMeasure.value
          && ('' + charMeasure.value).includes('ALIVE')
          && 'validation_earliest_death_resighting' in record.bird
          && record.bird.validation_earliest_death_resighting
          && Moment(record.event.event_timestamp).isAfter(Moment(record.bird.validation_earliest_death_resighting))) {
          errors.push(customErrorFactory.getError('InvalidStatusCode', ['DEAD', charMeasure.value, charMeasure.value, `/${idx}/characteristic_measurement/${innerIdx}`, MomentTimezone(record.bird.validation_earliest_death_resighting).tz('NZ').format('DD/MM/YYYY hh:mm:ss A'), MomentTimezone(record.event.event_timestamp).tz('NZ').format('DD/MM/YYYY hh:mm:ss A')]));
        }
      });

      // 9) Send a warning when the bird is reported as DEAD previously in it's timeline
      if ('validation_earliest_death_resighting' in record.bird
        && record.bird.validation_earliest_death_resighting) {
        // --------------------------------------------------------
        errors.push(customErrorFactory.getError('BirdStatusDeadWarning', [record.bird.id, `/${idx}/bird/id,/${idx}/mark_configuration`]));
      }

      // 10) Capture critical error to reduce scope for bird-id updates to just those events without mark associations
      if ('override_bird_id_attempt' in record.bird
        && record.bird.override_bird_id_attempt
        && record.mark_configuration.filter(markConfig => { return markConfig.mark_id; }).length > 0) {
        // --------------------------------------------------------
        errors.push(customErrorFactory.getError('StockBirdAssociationOnly', [record.bird.id, `/${idx}/bird/id,/${idx}/mark_configuration`]));
      }

      // 11) Capture critical error when multiple bird associations are possible as part of a record
      if ('bird_association_length' in record.bird
        && record.bird.bird_association_length
        && record.bird.bird_association_length > 1) {
        // --------------------------------------------------------
        let bandNumbers = record.mark_configuration.filter(markConfig => markConfig.mark_id).map(markConfig => markConfig.alphanumeric_text);
        errors.push(customErrorFactory.getError('MultipleBirdAssociationsPossible', [record.mark_configuration, `/${idx}/mark_configuration`, record.bird.bird_association_length, bandNumbers]));
      }

    });
  }

  // -----------------------------------------
  // VALIDATE DATA RELATED TO THE BANDERS (IF KNOWN)
  // -----------------------------------------
  if (validations.includes('bander')) {
    // PLACEHOLDER FOR BANDER VALIDATIONS
  }

  // -----------------------------------------
  // VALIDATE DATA RELATED TO LOCATION (IF KNOWN)
  // -----------------------------------------
  if (validations.includes('location')) {
    // -----------------------------------
    const MIN_NORTHING_NZTM = 4600000;
    const MAX_NORTHING_NZTM = 6300000;
    const MIN_EASTING_NZTM = 1000000;
    const MAX_EASTING_NZTM = 2200000;
    const MIN_NORTHING_NZMG = 5200000;
    const MAX_NORTHING_NZMG = 6900000;
    const MIN_EASTING_NZMG = 1900000;
    const MAX_EASTING_NZMG = 3100000;
    
    data.map((record, idx) => {
      // 1) Validate user northing and easting if provided with NZTM coordinate system
      if (record.event.user_coordinate_system === 'NZTM'
        && record.event.user_easting
        && ((record.event.user_easting < MIN_EASTING_NZTM || record.event.user_easting > MAX_EASTING_NZTM)
          || (record.event.user_northing < MIN_NORTHING_NZTM || record.event.user_northing > MAX_NORTHING_NZTM))) {
        errors.push(customErrorFactory.getError('InvalidProjectedCoordinate',
          [
            record.event.user_coordinate_system,
            MIN_EASTING_NZTM,
            `${record.event.user_coordinate_system}, ${record.event.user_easting}mE, ${record.event.user_northing}mN`,
            `/${idx}/event/user_coordinate_system,/${idx}/event/user_easting,/${idx}/event/user_northing`,
            MAX_EASTING_NZTM,
            MIN_NORTHING_NZTM,
            MAX_NORTHING_NZTM
          ]));
      }

      // 2) Validate user northing and easting if provided with NZMG coordinate system
      if (record.event.user_coordinate_system === 'NZMG'
        && record.event.user_easting
        && ((record.event.user_easting < MIN_EASTING_NZMG || record.event.user_easting > MAX_EASTING_NZMG)
          || (record.event.user_northing < MIN_NORTHING_NZMG || record.event.user_northing > MAX_NORTHING_NZMG))) {
        errors.push(customErrorFactory.getError('InvalidProjectedCoordinate',
          [
            record.event.user_coordinate_system,
            MIN_EASTING_NZMG,
            `${record.event.user_coordinate_system}, ${record.event.user_easting}mE, ${record.event.user_northing}mN`,
            `/${idx}/event/user_coordinate_system,/${idx}/event/user_easting,/${idx}/event/user_northing`,
            MAX_EASTING_NZMG,
            MIN_NORTHING_NZMG,
            MAX_NORTHING_NZMG
          ]));
      }

    });
  }

  console.log(errors);
  return errors;
}


const validateSpreadsheetRowBusinessRules = async (customErrorFactory, claims, governingCognitoGroup, validations, data, fieldMapping) => {
  // ------------------------------------------
  console.info('Validating spreadsheet row business rules');

  let errors = [];

  // ----------------------------------------------------------
  // WARN THE USER IF ANY INTERMEDIATE ROWS HAVE BEEN SKIPPED
  // ----------------------------------------------------------

  // -----------------------------------------
  // VALIDATE DATA RELATED TO EVENT (IF KNOWN)
  // -----------------------------------------
  if (validations.includes('event')) {
    // -----------------------------------
    data.map((record, idx) => {
      let event = record.event;
      // 1) For bird in-hand events, capture_type is required where wild captive not release site or captivity
      if ('event_type' in event
        && 'event_capture_type' in event
        && event.event_type.includes('IN_HAND')
        && ['WILD', 'SOURCE_SITE'].includes(event.event_bird_situation)
        && !event.event_capture_type) {
        // ------------------------------------
        errors.push(customErrorFactory.getError('RelatedPropertyRequired',
          [
            `For event_type: ${event.event_type}`,
            null,
            `${record.metadata.eventIndex + fieldMapping.starting_row},${fieldMapping.backTranslationProperties['event_capture_type'].ss_col}`,
            fieldMapping.backTranslationProperties['event_capture_type'].ss_col
          ]
        ));
      }

      // 2) Validate top-level characteristic_measurements (OUT_STATUS_CODE - , OUT_CONDITION_CODE)
      record.characteristic_measurement.map((charMeasure, innerIdx) => {
        if (charMeasure.characteristic_id === 43 && !ALLOWABLE_STATUS_CODES.includes(charMeasure.value)) {
          errors.push(customErrorFactory.getError('PropertyEnumError',
            [
              `Status_code_1 or Status_code_2`,
              charMeasure.value,
              `${record.metadata.eventIndex + fieldMapping.starting_row},Status_code`,
              ALLOWABLE_STATUS_CODES
            ]
          ));
        }
        if (charMeasure.characteristic_id === 44 && !ALLOWABLE_CONDITION_CODES.includes(charMeasure.value)) {
          errors.push(customErrorFactory.getError('PropertyEnumError',
            [
              `Condition_1 or Condition_2`,
              charMeasure.value,
              `${record.metadata.eventIndex + fieldMapping.starting_row},Condition`,
              ALLOWABLE_CONDITION_CODES
            ]));
        }
      });
    });


  }

  // -----------------------------------------
  // VALIDATE DATA RELATED TO THE MARK_CONFIGURATION<->EVENT (IF KNOWN)
  // -----------------------------------------
  if (validations.includes('markConfiguration')) {
    // ----------------------------------------------------

    data.map((record, idx) => {
      // -----------------------------------
      // For each event, complete validation of the mark_configuration

      // 1) Validate that at least 1 mark is provided in the mark_configuration (should hold true for all cases EXCEPT WHERE EVENT_TYPE = IN_HAND_POST_CHANGE, i.e. where all bands can be removed)
      //  -- Updated to allow empty release configuration for remarking events (i.e. birds where all bands are removed - must have mark configuration capture)
      if (record.event.event_type !== 'IN_HAND_POST_CHANGE'
        && record.mark_configuration.length === 0) {
        errors.push(customErrorFactory.getError('InvalidEmptyListProperty',
          [
            `Left_tibia,Left_tarsus,Right_tibia,Right_tarsus,Non_leg_mark_type`,
            '',
            `${record.metadata.eventIndex + fieldMapping.starting_row},Mark_configuration`,
          ]
        ));
      }

      // 2) Validate event_type/mark_state relationships
      record.mark_configuration.map((markConfig, innerIdx) => {
        // ---------------------------------------
        // For first marking, marks should be in the 'ALLOCATED' state
        if (markConfig.mark_id && ['FIRST_MARKING_IN_HAND'].includes(record.event.event_type) && markConfig.validation_state && !['ALLOCATED'].includes(markConfig.validation_state)) {
          // --------------------------------------------------
          errors.push(customErrorFactory.getError('MarkStateLifecycleError',
            [
              'Marks should be ALLOCATED before being used as release marks for FIRST_MARKING_IN_HAND',
              'This can happen when results are submitted out of order',
              markConfig.validation_state,
              `${record.metadata.eventIndex + fieldMapping.starting_row},Mark_configuration`,
              'WARNING'
            ]
          ));
        }
        // For in hand events, marks must be in the 'ALLOCATED' or 'ATTACHED' state
        if (markConfig.mark_id && ['IN_HAND', 'IN_HAND_PRE_CHANGE', 'IN_HAND_POST_CHANGE'].includes(record.event.event_type) && markConfig.validation_state && !['ALLOCATED', 'ATTACHED'].includes(markConfig.validation_state)) {
          errors.push(customErrorFactory.getError('MarkStateLifecycleError',
            [
              'Marks should be ALLOCATED or ATTACHED before being used a release marks for IN_HAND, IN_HAND_PRE_CHANGE or IN_HAND_POST_CHANGE',
              'This can happen when results are submitted out of chronological order',
              markConfig.validation_state,
              `${record.metadata.eventIndex + fieldMapping.starting_row},Mark_configuration`,
              'WARNING'
            ]
          ));
        }
        // For resighting by person or recorded by technology events, marks must be in the 'ATTACHED' state
        if (markConfig.mark_id && ['SIGHTING_BY_PERSON', 'RECORDED_BY_TECHNOLOGY'].includes(record.event.event_type) && markConfig.validation_state && !['ATTACHED'].includes(markConfig.validation_state)) {
          errors.push(customErrorFactory.getError('MarkStateLifecycleError',
            [
              'Marks should be ATTACHED before being SIGHTED_BY_PERSON or RECORDED_BY_TECHNOLOGY',
              'This can happen when results are submitted out of chronological order',
              markConfig.validation_state,
              `${record.metadata.eventIndex + fieldMapping.starting_row},Mark_configuration`,
              'WARNING'
            ]
          ));
        }
        // 2A) Warn the user if the event is before the event associated with the current mark_state as they should not expect a mark_state change in this case
        if (markConfig.mark_id && markConfig.validation_last_event_timestamp
          && Moment(record.event.event_timestamp).isSameOrBefore(Moment(markConfig.validation_last_event_timestamp))) {
          errors.push(customErrorFactory.getError('MarkStateLifecycleError',
            [
              `${markConfig.alphanumeric_text} changed state to ${markConfig.validation_state} on ${MomentTimezone(markConfig.validation_last_event_timestamp).tz('NZ').format('DD/MM/YYYY hh:mm:ss A')} which is after this event on ${MomentTimezone(record.event.event_timestamp).tz('NZ').format('DD/MM/YYYY hh:mm:ss A')}`,
              `Please be aware that submitting an event earlier than what already exists in the database will not update the current state for ${markConfig.alphanumeric_text}`,
              MomentTimezone(record.event.event_timestamp).tz('NZ').format('DD/MM/YYYY hh:mm:ss A'),
              `${record.metadata.eventIndex + fieldMapping.starting_row},Date`,
              'WARNING'
            ]
          ));
        }
      });

      // 3) Validate that there is at least one association to known stock items, if not warn the user
      if (record.mark_configuration.filter(markConfig => markConfig.mark_id).length === 0) {
        let alphanumericTextValues = record.mark_configuration.filter(markConfig => markConfig.alphanumeric_text).map(markConfig => markConfig.alphanumeric_text);
        alphanumericTextValues = (alphanumericTextValues.length === 0) ? ['No alphanumerics'] : alphanumericTextValues;
        errors.push(customErrorFactory.getError('NoStockAssociationPossible',
          [
            alphanumericTextValues.join(', '),
            `${record.metadata.eventIndex + fieldMapping.starting_row},Mark_configuration`,
            alphanumericTextValues.join(', ')
          ]
        ));
      }

      // 4) Check whether the primary mark has been included in the mark configuration
      //  - if not provide a warning to let the user know
      if (record.mark_configuration.filter(markConfig => markConfig.alphanumeric_text && markConfig.alphanumeric_text.toLowerCase() === record.metadata.primaryMark.toLowerCase()).length === 0) {
        // -----------------------------------------------------
        errors.push(customErrorFactory.getError('MissingPrimaryMark',
          [
            `${record.metadata.primaryMark}`,
            `row ${record.metadata.eventIndex + fieldMapping.starting_row}`,
            `(col AF to AY)`,
            `${record.metadata.eventIndex + fieldMapping.starting_row},Prefix and Number`,
            `Non_leg_mark_id`
          ]
        ));
      }
    });
  }

  // -----------------------------------------
  // VALIDATE DATA RELATED TO THE EXISTING BIRD (IF KNOWN)
  // -----------------------------------------
  if (validations.includes('bird')) {
    // -----------------------------------------------
    data.map((record, idx) => {
      // ----------------------------------------
      // 1a) If the record is a first_marking_in_hand event, there should not be an existing first marking event
      if (record.event.event_type === 'FIRST_MARKING_IN_HAND'
        && 'validation_first_marking_timestamp' in record.bird
        && record.bird.validation_first_marking_timestamp) {
        errors.push(customErrorFactory.getError('BirdAlreadyHasFirstMarkingError',
          [
            `${process.env.APPLICATION_DOMAIN}/view-data/bird/${record.bird.id}`,
            MomentTimezone(record.bird.validation_first_marking_timestamp).tz('NZ').format('DD/MM/YYYY hh:mm:ss A'),
            record.event.event_type,
            `${record.metadata.eventIndex + fieldMapping.starting_row},Event_code`,
          ]
        ));
      }

      // 1b) If the record is a first_marking_in_hand event, there should not be any resightings before it
      if (record.event.event_type === 'FIRST_MARKING_IN_HAND'
        && 'validation_earliest_resighting_timestamp' in record.bird
        && record.bird.validation_earliest_resighting_timestamp
        && Moment(record.event.event_timestamp).isAfter(Moment(record.bird.validation_earliest_resighting_timestamp))) {
        errors.push(customErrorFactory.getError('SightingBeforeFirstMarkingError',
          [
            `${process.env.APPLICATION_DOMAIN}/view-data/bird/${record.bird.id}`,
            MomentTimezone(record.bird.validation_earliest_resighting_timestamp).tz('NZ').format('DD/MM/YYYY hh:mm:ss A'),
            MomentTimezone(record.event.event_timestamp).tz('NZ').format('DD/MM/YYYY hh:mm:ss A'),
            `${record.metadata.eventIndex + fieldMapping.starting_row},Date`
          ]
        ));
      }

      // 1c) If the record is not a first_marking_in_hand event, it should not be before the first_marking event if it exists
      if (record.event.event_type !== 'FIRST_MARKING_IN_HAND'
        && 'validation_first_marking_timestamp' in record.bird
        && record.bird.validation_first_marking_timestamp
        && Moment(record.event.event_timestamp).isBefore(Moment(record.bird.validation_first_marking_timestamp))) {
          let severity = (['SOURCE_SITE', 'CAPTIVE'].includes(record.event.event_bird_situation)) ? 'WARNING' : 'CRITICAL';
          errors.push(customErrorFactory.getError('SightingBeforeFirstMarkingError',
          [
            `${process.env.APPLICATION_DOMAIN}/view-data/bird/${record.bird.id}`,
            MomentTimezone(record.event.event_timestamp).tz('NZ').format('DD/MM/YYYY hh:mm:ss A'),
            MomentTimezone(record.bird.validation_first_marking_timestamp).tz('NZ').format('DD/MM/YYYY hh:mm:ss A'),
            `${record.metadata.eventIndex + fieldMapping.starting_row},Date`,
            severity
          ]
        ));
      }

      // 2) If any DOC stock is involved, we should validate that a correct prefix size has been used
      if ('validation_valid_band_prefixes' in record.bird
        && record.bird.validation_valid_band_prefixes) {
        // ------------------------------------------------------
        record.mark_configuration.map((markConfig, innerIdx) => {
          if ('mark_id' in markConfig
            && markConfig.mark_id
            && 'validation_prefix_number' in markConfig
            && markConfig.validation_prefix_number
            && record.bird.validation_valid_band_prefixes
            && !record.bird.validation_valid_band_prefixes.replace(/ /g, '').split(',').includes(markConfig.validation_prefix_number)) {
            errors.push(customErrorFactory.getError('UnexpectedSpeciesBandPrefix',
              [
                markConfig.validation_prefix_number,
                record.bird.species_common_name,
                markConfig.validation_prefix_number,
                `${record.metadata.eventIndex + fieldMapping.starting_row},Mark_configuration`,
                record.bird.validation_valid_band_prefixes
              ]
            ));
          }
        });
      }

      // 3) If a bird exists in the system then the species definition should match the existing definition
      if ('validation_species_id' in record.bird
        && record.bird.validation_species_id
        && record.bird.species_id !== record.bird.validation_species_id) {
        errors.push(customErrorFactory.getError('BirdSpeciesConflictError',
          [
            `${process.env.APPLICATION_DOMAIN}/view-data/bird/${record.bird.id}`,
            record.bird.validation_species_common_name, record.bird.species_common_name,
            `${record.metadata.eventIndex + fieldMapping.starting_row},Species_code`,
            'CRITICAL'
          ]
        ));
      }

      // 4) If the record is not a first_marking_in_hand event, and a first marking event doesn't exist warn the user
      if (record.event.event_type !== 'FIRST_MARKING_IN_HAND'
        && (!record.bird.id
          || !('validation_first_marking_timestamp' in record.bird)
          || !record.bird.validation_first_marking_timestamp)) {
        let allMarks = record.mark_configuration.filter(markConfig => markConfig.alphanumeric_text).map(markConfig => markConfig.alphanumeric_text).join(', ');
        errors.push(customErrorFactory.getError('BirdMissingFirstMarking',
          [
            null, null, allMarks,
            `${record.metadata.eventIndex + fieldMapping.starting_row},Mark_configuration`,
          ]
        ));
      }

      record.characteristic_measurement.map((charMeasure, innerIdx) => {
        // 5) Validate that the bird is not being reported dead before it has been recorded as alive
        if (charMeasure.characteristic_id === 43
          && charMeasure.value
          && ('' + charMeasure.value).includes('DEAD')
          && 'validation_latest_alive_resighting' in record.bird
          && record.bird.validation_latest_alive_resighting
          && Moment(record.event.event_timestamp).isBefore(Moment(record.bird.validation_latest_alive_resighting))) {
          errors.push(customErrorFactory.getError('InvalidStatusCode',
            [
              charMeasure.value,
              'ALIVE',
              charMeasure.value,
              `${record.metadata.eventIndex + fieldMapping.starting_row},Status_code`,
              MomentTimezone(record.event.event_timestamp).tz('NZ').format('DD/MM/YYYY hh:mm:ss A'),
              MomentTimezone(record.bird.validation_latest_alive_resighting).tz('NZ').format('DD/MM/YYYY hh:mm:ss A')
            ]
          ));
        }
        // 6) Validate that the bird is not being reported alive after it has been recorded as dead
        if (charMeasure.characteristic_id === 43
          && charMeasure.value
          && ('' + charMeasure.value).includes('ALIVE')
          && 'validation_earliest_death_resighting' in record.bird
          && record.bird.validation_earliest_death_resighting
          && Moment(record.event.event_timestamp).isAfter(Moment(record.bird.validation_earliest_death_resighting))) {
          errors.push(customErrorFactory.getError('InvalidStatusCode',
            [
              'DEAD', charMeasure.value, charMeasure.value,
              `${record.metadata.eventIndex + fieldMapping.starting_row},Status_code`,
              MomentTimezone(record.bird.validation_earliest_death_resighting).tz('NZ').format('DD/MM/YYYY hh:mm:ss A'),
              MomentTimezone(record.event.event_timestamp).tz('NZ').format('DD/MM/YYYY hh:mm:ss A')
            ]
          ));
        }
      });

      // 9) Send a warning when the bird is reported as DEAD previously in it's timeline
      if ('validation_earliest_death_resighting' in record.bird
        && record.bird.validation_earliest_death_resighting) {
        // --------------------------------------------------------
        errors.push(customErrorFactory.getError('BirdStatusDeadWarning',
          [
            record.bird.id,
            `${record.metadata.eventIndex + fieldMapping.starting_row},Mark_configuration`,
          ]
        ));
      }

      // 10) Capture critical error when multiple bird associations are possible as part of a record
      if ('bird_association_length' in record.bird
        && record.bird.bird_association_length
        && record.bird.bird_association_length > 1) {
        // --------------------------------------------------------
        let bandNumbers = record.mark_configuration.filter(markConfig => markConfig.mark_id).map(markConfig => markConfig.alphanumeric_text);
        errors.push(customErrorFactory.getError('MultipleBirdAssociationsPossible',
          [
            record.mark_configuration,
            `${record.metadata.eventIndex + fieldMapping.starting_row},Mark_configuration`,
            record.bird.bird_association_length,
            bandNumbers
          ]
        ));
      }

      // 11) Capture critical error when a species_id cannot be associated to this record
      if (!record.bird.species_id) {
      // --------------------------------------------------------
      let bandNumbers = record.mark_configuration.filter(markConfig => markConfig.mark_id).map(markConfig => markConfig.alphanumeric_text);
      errors.push(customErrorFactory.getError('InvalidSpeciesCode',
        [
          record.bird.raw_species_code_nznbbs,
          `${record.metadata.eventIndex + fieldMapping.starting_row},Species_code`,
          `row ${record.metadata.eventIndex + fieldMapping.starting_row}`
        ]
      ));
      }
    });
  }
  // -----------------------------------------
  // VALIDATE DATA RELATED TO THE BANDERS (IF KNOWN)
  // -----------------------------------------
  if (validations.includes('bander')) {
    // -------------------------------------------------------
    // 1) Validate that the event_reporter_id and event_provider_id could be looked up based on the certification number
    data.map((record, idx) => {
      // ----------------------------------------
      if (!record.event.event_reporter_id) {
        errors.push(customErrorFactory.getError('BanderNotFound',
          [
            record.event.raw_event_reporter_nznbbs_certification_number,
            `${record.metadata.eventIndex + fieldMapping.starting_row},Bander_number`,
            `Bander_number`
          ]
        ));
      }

      if (!record.event.event_provider_id) {
        errors.push(customErrorFactory.getError('BanderNotFound',
          [
            record.event.raw_event_provider_nznbbs_certification_number,
            `${record.metadata.eventIndex + fieldMapping.starting_row},L3_number`,
            `L3_number`
          ]
        ));
      }
    });
  }

  // -----------------------------------------
  // VALIDATE DATA RELATED TO LOCATION (IF KNOWN)
  // -----------------------------------------
  if (validations.includes('location')) {
    // -----------------------------------
    const MIN_NORTHING_NZTM = 4600000;
    const MAX_NORTHING_NZTM = 6300000;
    const MIN_EASTING_NZTM = 1000000;
    const MAX_EASTING_NZTM = 2200000;
    const MIN_NORTHING_NZMG = 5200000;
    const MAX_NORTHING_NZMG = 6900000;
    const MIN_EASTING_NZMG = 1900000;
    const MAX_EASTING_NZMG = 3100000;

    data.map((record, idx) => {

      // 1A) Check at least one pair of coordinates have been supplied
      if (((!record.event.latitude || record.event.latitude === 0) || (!record.event.longitude || record.event.longitude === 0))
        && ((!record.event.user_northing || record.event.user_northing === 0) || (!record.event.user_easting || record.event.user_easting === 0))) {
        // ---------------------------------------------
        errors.push(customErrorFactory.getError('CoordinatesRequired',
          [
            `${record.metadata.eventIndex + fieldMapping.starting_row},Coordinates`,
          ]));
      }
      // 1B) Validate user northing and easting if provided with NZTM coordinate system
      if (record.event.user_coordinate_system === 'NZTM'
        && record.event.user_easting
        && ((record.event.user_easting < MIN_EASTING_NZTM || record.event.user_easting > MAX_EASTING_NZTM)
          || (record.event.user_northing < MIN_NORTHING_NZTM || record.event.user_northing > MAX_NORTHING_NZTM))) {
        errors.push(customErrorFactory.getError('InvalidProjectedCoordinate',
          [
            record.event.user_coordinate_system,
            MIN_EASTING_NZTM,
            `${record.event.user_coordinate_system}, ${record.event.user_easting}mE, ${record.event.user_northing}mN`,
            `${record.metadata.eventIndex + fieldMapping.starting_row},Coordinate system`,
            MAX_EASTING_NZTM,
            MIN_NORTHING_NZTM,
            MAX_NORTHING_NZTM
          ]));
      }

      // 2) Validate user northing and easting if provided with NZMG coordinate system
      if (record.event.user_coordinate_system === 'NZMG'
        && record.event.user_easting
        && ((record.event.user_easting < MIN_EASTING_NZMG || record.event.user_easting > MAX_EASTING_NZMG)
          || (record.event.user_northing < MIN_NORTHING_NZMG || record.event.user_northing > MAX_NORTHING_NZMG))) {
        errors.push(customErrorFactory.getError('InvalidProjectedCoordinate',
          [
            record.event.user_coordinate_system,
            MIN_EASTING_NZMG,
            `${record.event.user_coordinate_system}, ${record.event.user_easting}mE, ${record.event.user_northing}mN`,
            `${record.metadata.eventIndex + fieldMapping.starting_row},Coordinate system`,
            MAX_EASTING_NZMG,
            MIN_NORTHING_NZMG,
            MAX_NORTHING_NZMG
          ]));
      }

    });
  }

  return errors;
}


const validateIntraSpreadsheetBusinessRules = async (customErrorFactory, claims, governingCognitoGroup, validations, data, fieldMapping) => {
  // ------------------------------------------
  console.info('Validating intra spreadsheet business rules');

  let errors = [];

  // -----------------------------------------
  // VALIDATE DATA RELATED TO EVENT (IF KNOWN)
  // -----------------------------------------
  if (validations.includes('event')) {
    // -----------------------------------
  }

  // -----------------------------------------
  // VALIDATE DATA RELATED TO THE MARK_CONFIGURATION<->EVENT (IF KNOWN)
  // -----------------------------------------
  if (validations.includes('markConfiguration')) {
    // ----------------------------------------------------
  }

  // -----------------------------------------
  // VALIDATE DATA RELATED TO THE EXISTING BIRD (IF KNOWN)
  // -----------------------------------------
  const isSameBird = (subjectRecord, checkRecord) => {
    // -----------------------------------
    return (
      typeof subjectRecord.mark_configuration.find(markConfig => {
        return (markConfig.mark_id
          && typeof checkRecord.mark_configuration.find(checkMarkConfig => checkMarkConfig.mark_id && checkMarkConfig.mark_id === markConfig.mark_id) !== 'undefined');
      }) !== 'undefined'
    );
  }

  const isSameSpecies = (subjectRecord, checkRecord) => {
    // -----------------------------------
    return (
      subjectRecord.bird.species_id === checkRecord.bird.species_id
    );
  }

  const isDead = (record) => {
    // -----------------------------------
    return (
      typeof record.characteristic_measurement.find(charMeasure => {
        return (charMeasure.characteristic_id === 43
          && charMeasure.value
          && ('' + charMeasure.value).includes('DEAD'))
      }) !== 'undefined'
    );
  }

  const isAlive = (record) => {
    // -----------------------------------
    return (
      typeof record.characteristic_measurement.find(charMeasure => {
        return (charMeasure.characteristic_id === 43
          && charMeasure.value
          && ('' + charMeasure.value).includes('ALIVE'))
      }) !== 'undefined'
    );
  }

  if (validations.includes('bird')) {
    // -----------------------------------
    data.map((record, idx) => {
      // -----------------------------------
      console.info('Validating intra spreadsheet bird details');

      // First lets slice the data array to shallow copy all records which come before the current record (for comparison)
      // -> This means the first record will always be 'valid' intra-spreadsheet
      let checkRecords = data.slice(0, idx);

      // 1a) If the record is a first_marking_in_hand event, there should not be an existing first marking event
      let duplicateFirstMarkingRecord = (record.event.event_type === 'FIRST_MARKING_IN_HAND') ?
        checkRecords.find(checkRecord => checkRecord.event.event_type === 'FIRST_MARKING_IN_HAND'
          && isSameBird(record, checkRecord)) : null;

      if (typeof duplicateFirstMarkingRecord !== 'undefined' && duplicateFirstMarkingRecord) {
        // --------------------------------------------------------------------------
        errors.push(customErrorFactory.getError('BirdAlreadyHasFirstMarkingError',
          [
            `in row ${record.metadata.eventIndex + fieldMapping.starting_row}`,
            `${MomentTimezone(duplicateFirstMarkingRecord.event.event_timestamp).tz('NZ').format('DD/MM/YYYY hh:mm:ss A')} in row ${duplicateFirstMarkingRecord.metadata.eventIndex + fieldMapping.starting_row}`,
            record.event.event_type,
            `${record.metadata.eventIndex + fieldMapping.starting_row},Event_code`,
          ]
        ));
      }

      // 1b) If the record is a first_marking_in_hand event, there should not be any resightings before it
      let invalidEarlierResightings = (record.event.event_type === 'FIRST_MARKING_IN_HAND') ?
        checkRecords.filter(checkRecord => checkRecord.event.event_type !== 'FIRST_MARKING_IN_HAND'
          && !['SOURCE_SITE', 'CAPTIVE'].includes(checkRecord.event.event_bird_situation)
          && isSameBird(record, checkRecord) && Moment(record.event.event_timestamp).isAfter(Moment(checkRecord.event.event_timestamp))) : [];

      if (invalidEarlierResightings.length > 0) {
        let rowText = invalidEarlierResightings.length > 1 ? 'rows' : 'row';
        let respectivelyText = invalidEarlierResightings.length > 1 ? ' respectively,' : ',';
        errors.push(customErrorFactory.getError('SightingBeforeFirstMarkingError',
          [
            `first marked in row ${record.metadata.eventIndex + fieldMapping.starting_row} is also sighted in ${rowText} ${invalidEarlierResightings.map(invalidRecord => `${invalidRecord.metadata.eventIndex + fieldMapping.starting_row}`).join(' and ')}. Being`,
            `${invalidEarlierResightings.map(invalidRecord => `${MomentTimezone(invalidRecord.event.event_timestamp).tz('NZ').format('DD/MM/YYYY hh:mm:ss A')}`).join(' and ')}${respectivelyText}`,
            `${MomentTimezone(record.event.event_timestamp).tz('NZ').format('DD/MM/YYYY hh:mm:ss A')}`,
            `${record.metadata.eventIndex + fieldMapping.starting_row},Date`
          ]
        ));
      }

      // 1c) If the record is not a first_marking_in_hand event, it should not be before the first_marking event if it exists
      let invalidLaterFirstMarkings = (record.event.event_type !== 'FIRST_MARKING_IN_HAND') ?
        checkRecords.filter(checkRecord => checkRecord.event.event_type === 'FIRST_MARKING_IN_HAND'
          && isSameBird(record, checkRecord) && Moment(record.event.event_timestamp).isBefore(Moment(checkRecord.event.event_timestamp))) : [];

      if (invalidLaterFirstMarkings.length > 0) {
        let rowText = invalidLaterFirstMarkings.length > 1 ? 'rows' : 'row';
        let respectivelyText = invalidLaterFirstMarkings.length > 1 ? ' respectively,' : ',';
        let severity = (['SOURCE_SITE', 'CAPTIVE'].includes(record.event.event_bird_situation)) ? 'WARNING' : 'CRITICAL';
        errors.push(customErrorFactory.getError('SightingBeforeFirstMarkingError',
          [
            `sighted in row ${record.metadata.eventIndex + fieldMapping.starting_row} is also first-marked in ${rowText} ${invalidLaterFirstMarkings.map(invalidRecord => `${invalidRecord.metadata.eventIndex + fieldMapping.starting_row}`).join(' and ')}. Being`,
            `${MomentTimezone(record.event.event_timestamp).tz('NZ').format('DD/MM/YYYY hh:mm:ss A')}`,
            `${invalidLaterFirstMarkings.map(invalidRecord => `${MomentTimezone(invalidRecord.event.event_timestamp).tz('NZ').format('DD/MM/YYYY hh:mm:ss A')}`).join(' and ')}${respectivelyText}`,
            `${record.metadata.eventIndex + fieldMapping.starting_row},Date`,
            severity
          ]
        ));
      }

      // 2) If a bird is recorded in the spreadsheet, ensure the species definition does not change between rows
      let invalidSpeciesChange = checkRecords.find(checkRecord => isSameBird(record, checkRecord) && !isSameSpecies(record, checkRecord));
      if (typeof invalidSpeciesChange !== 'undefined' && invalidSpeciesChange) {
        // --------------------------------------------------------------------------
        errors.push(customErrorFactory.getError('BirdSpeciesConflictError',
          [
            `in row ${record.metadata.eventIndex + fieldMapping.starting_row}`,
            `${invalidSpeciesChange.bird.species_common_name} in row ${invalidSpeciesChange.metadata.eventIndex + fieldMapping.starting_row}`,
            record.bird.species_common_name,
            `${record.metadata.eventIndex + fieldMapping.starting_row},Common_name`,
            'CRITICAL'
          ]
        ));
      }

      // 3) Validate that the bird is not being reported dead before it has been recorded as alive
      let invalidDeadBeforeAlive = checkRecords.find(checkRecord => isDead(record) && isAlive(checkRecord)
        && isSameBird(record, checkRecord) && Moment(record.event.event_timestamp).isBefore(Moment(checkRecord.event.event_timestamp)));
      if (typeof invalidDeadBeforeAlive !== 'undefined' && invalidDeadBeforeAlive) {
        // --------------------------------------------------------------------------
        errors.push(customErrorFactory.getError('InvalidStatusCode',
          [
            'DEAD',
            'ALIVE',
            record.characteristic_measurement.find(charMeasure => charMeasure.characteristic_id === 43)['value'],
            `${record.metadata.eventIndex + fieldMapping.starting_row},Status_code`,
            `row ${record.metadata.eventIndex + fieldMapping.starting_row}: ${MomentTimezone(record.event.event_timestamp).tz('NZ').format('DD/MM/YYYY hh:mm:ss A')}`,
            `row ${invalidDeadBeforeAlive.metadata.eventIndex + fieldMapping.starting_row}: ${MomentTimezone(invalidDeadBeforeAlive.event.event_timestamp).tz('NZ').format('DD/MM/YYYY hh:mm:ss A')}`
          ]
        ));
      }

      // 3) Validate that the bird is not being reported alive after it has been recorded as dead
      let invalidAliveBeforeDead = checkRecords.find(checkRecord => isAlive(record) && isDead(checkRecord)
        && isSameBird(record, checkRecord) && Moment(record.event.event_timestamp).isAfter(Moment(checkRecord.event.event_timestamp)));
      if (typeof invalidAliveBeforeDead !== 'undefined' && invalidAliveBeforeDead) {
        // --------------------------------------------------------------------------
        errors.push(customErrorFactory.getError('InvalidStatusCode',
          [
            'DEAD',
            'ALIVE',
            record.characteristic_measurement.find(charMeasure => charMeasure.characteristic_id === 43)['value'],
            `${record.metadata.eventIndex + fieldMapping.starting_row},Status_code`,
            `row ${invalidAliveBeforeDead.metadata.eventIndex + fieldMapping.starting_row}: ${MomentTimezone(invalidAliveBeforeDead.event.event_timestamp).tz('NZ').format('DD/MM/YYYY hh:mm:ss A')}`,
            `row ${record.metadata.eventIndex + fieldMapping.starting_row}: ${MomentTimezone(record.event.event_timestamp).tz('NZ').format('DD/MM/YYYY hh:mm:ss A')}`
          ]
        ));
      }
    });
  }

  // -----------------------------------------
  // VALIDATE DATA RELATED TO THE BANDERS (IF KNOWN)
  // -----------------------------------------
  if (validations.includes('bander')) {
    // -----------------------------------
  }

  // -----------------------------------------
  // VALIDATE DATA RELATED TO LOCATION (IF KNOWN)
  // -----------------------------------------
  if (validations.includes('location')) {
    // -----------------------------------
  }

  return errors;
}




// =============
// EXPORTS
// =============

module.exports = {
  // FUNCTIONS
  validateUploadAccess,
  validateUpdateAccess,
  validateGetAccess,
  validateDeleteAccess,
  validateEventExists,
  validatePayloadStructure,
  formatSchemaErrors,
  getPostLookupData,
  getPutLookupData,
  getSpreadsheetLookupData,
  supplementPostEventWithLookupData,
  supplementPutEventWithLookupData,
  supplementSpreadsheetEventsWithLookupData,
  validatePostBusinessRules,
  validatePutBusinessRules,
  validateSpreadsheetRowBusinessRules,
  validateIntraSpreadsheetBusinessRules
};