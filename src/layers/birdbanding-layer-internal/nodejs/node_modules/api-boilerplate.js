'use strict';

/*
*   Drop this file into ./lib of your Serverless service.
*
*/

// =============
// MODULES
// =============
const Promise = require('bluebird');
const Util = require('util');
const AJV = require('ajv');

// Import and configure AWS module
var AWSXRay = require('aws-xray-sdk');
var AWS = AWSXRay.captureAWS(require('aws-sdk'));
AWS.config.setPromisesDependency(require('bluebird'));

// =============
// CONSTS
// =============

// =============
// CLASSES
// =============
class ServiceError extends Error {
  constructor(message, details = {}, statusCode = 400, errorCode = 0) {

    // Calling parent constructor of base Error class.
    super(message);

    // Saving class name in the property of our custom error as a shortcut.
    this.name = this.constructor.name;

    // Capturing stack trace, excluding constructor call from it.
    Error.captureStackTrace(this, this.constructor);

    // You can use any additional properties you want.
    // status code is the HTTP return code,
    // errorCode is an internal error identifier.

    this.errorCode = errorCode;
    this.statusCode = statusCode;
    this.details = details;
  }
};

class AuthorisationError extends ServiceError {
  constructor(message, details = {}, statusCode = 401) {

    // Calling parent constructor of base Error class.
    super(message, details, statusCode, 1);
  }
};

class ForbiddenError extends ServiceError {
  constructor(message, details = {}, statusCode = 403) {

    // Calling parent constructor of base Error class.
    super(message, details, statusCode, 2);
  }
};

class SuspensionError extends ServiceError {
  constructor(message, details = {}, statusCode = 451) {

    // Calling parent constructor of base Error class.
    super(message, details, statusCode, 3);
  }
};

class ParameterValidationError extends ServiceError {
  constructor(message, details = {}, statusCode = 400) {

    // Calling parent constructor of base Error class.
    super(message, details, statusCode, 100);
  }
};

class DataAccessError extends ServiceError {
  constructor(message, details = {}, statusCode = 400) {

    // Calling parent constructor of base Error class.
    super(message, details, statusCode, 200);
  }
};

class NotFoundError extends ServiceError {
  constructor(message, details = {}, statusCode = 404) {

    // Calling parent constructor of base Error class.
    super(message, details, statusCode, 400);
  }
};

// =============
// FUNCTIONS
// =============

const cognitoGroupAuthCheck = (event, authGroups = []) => {
  // ----------------------------------------------------      
  return new Promise((resolve, reject) => {

    console.info("boilerplate.cognitoAuthCheck()");

    // Bring down the ban hammer
    if (!event.hasOwnProperty('requestContext')) {
      throw new AuthorisationError("Unauthorized!", "No request context available!");
    }

    // If no acceptable groups to match, return!
    if (authGroups.length <= 0) {
      throw new AuthorisationError("Unauthorized!", "No Authorisation groups defined!");
    }

    // Check if the event is complete
    if (!event || !event.requestContext || !event.requestContext.authorizer || !event.requestContext.authorizer.claims || !('cognito:groups' in event.requestContext.authorizer.claims)) {
      throw new AuthorisationError("Unauthorized!", "Authorizer/Claims not present or invalid!");
    }

    // Got a valid context to check against

    var claimedGroups = [];
    claimedGroups = claimedGroups.concat(event.requestContext.authorizer.claims['cognito:groups'].split(','));
    var claimed_expiry_date = Date.parse(event.requestContext.authorizer.claims['exp']);
    var now = new Date();

    // Check whether the token has expired!
    if (!claimed_expiry_date || now.getTime() > claimed_expiry_date) {
      throw new AuthorisationError("Unauthorized!", "Token expired!");
    }

    // Token has not yet expired. Continue.

    // Check if the claims contain any groups.
    if (!claimedGroups) {
      throw new AuthorisationError("Unauthorized!", "No group memberships!");
    }

    // See if our group membership matches any of the authorised groups
    if (claimedGroups.some(r => authGroups.indexOf(r) < 0)) {
      throw new AuthorisationError("Unauthorized!", "Not a member of any authorised groups!");
    }

    // Otherwise, there is much happiness!
    resolve(claimedGroups);
  });
};

// This method now a little different. We resolve with the error array
// regardless of whether we've found any errors at all. Errors may be further
// manipulated and massaged to be made human-readable (or something else) so
// we don't want to natively throw the error.
const validateJSON = (json, schema) => {
  // ---------------------------------------------------------------------------- 
  return new Promise((resolve, reject) => {

    console.info("boilerplate.validateJSON()");

    var errors = [];

    var ajv = new AJV({
      verbose: true,
      allErrors: true,
      jsonPointers: true,
      logger: false
    });

    // Perform the validation using the parsed schema
    var validator = ajv.compile(schema);
    var valid = validator(json, {});

    // Check if we've got validation errors. If so, iterate through and
    // Add them to the list.
    if (!valid) {
      validator.errors.forEach(err => {
        console.error("Full Error: " + Util.inspect(err, false, null));
        errors.push({
          type: 'SCHEMA',
          message: err.message,
          data: {
            keyword: err.keyword,
            value: err.data,
            params: err.params,
            path: JSON.stringify(err.dataPath)
          },
          schema: {
            path: err.schemaPath
          }
        });
      });

      // Errors!
      // console.error(Util.inspect(errors, false, null));
    }

    // Resolve with the error array, regardless of whether ther're any in there.
    return resolve(errors);
  });
};

// ???
const parseSubSchemas = (obj, key) => {
  // ---------------------------------------------------------------------------- 
  console.info("boilerplate.parseSubSchemas()");

  // I've inlcuded this function here as a TODO.
  // This function was originally a python function
  // designed to be recursively called to traverse
  // an object's properties, replacing references
  // to schemas in dynamo DB with the actual schemas
  // themselves once loaded from Dynamo. However, because
  // loading from Dynamo is a promise-based function, 
  // recursion is boggling my mind in that context, and
  // I haven't sorted it out yet - DD.

  // Iterate over the properties of this object
  Object.keys(obj).forEach(k => {
    var v = obj[k];
    // If the property is an object itself, rather than
    // a simple type (i.e. string, int), recurse into it
    if (v && typeof v === 'object' && v.constructor === Object) {
      obj[k] = parseSubSchemas(v, key);
    }
  })

  // If this object has the property that we're looking for
  // parse out the value into table:id:version and get it
  // from Dynamo, replacing the token as we go.
  if (obj.hasOwnProperty(key)) {
    var reference = obj[key];
    if (String(reference).startsWith("dynamodb://")) {
      ref_parts = reference.replace("dynamodb://", "").split(':');
      obj = getSchemaFromDynamo(ref_parts[0], ref_parts[1], Number(ref_parts[2]))
      parseSubSchemas(obj, key);
    }
  }

  return obj;
};

const getSchemaFromDynamo = (table, id, version) => {
  // ----------------------------------------------------------------------------

  console.info("boilerplate.getSchemaFromDynamo()");

  // Create the DynamoDB service document client locally
  var ddbClient = new AWS.DynamoDB.DocumentClient();

  // Get the schema definition from the table. There can only be one or zero - it is the table's
  // partition key - but use strong consistency so we respond instantly
  // to any change. This can be revisited if we want to conserve RCUs
  // by, say, caching this value and updating it every minute.
  var params = {
    TableName: table,
    Key: {
      id: id,
      version: version
    },
    ConsistentRead: true
  };

  console.info(JSON.stringify(params));

  // Get the item from Dynamo
  return ddbClient.get(params).promise()
    .then(res => {

      console.log(res);

      // Throw error if returned in error
      if (res.err) { console.error(res.err); throw new Error(res.err); }

      // Throw error if not found
      if (!res.Item) { throw new Error("Schema Not Found!"); }

      console.log("Dynamo Item: " + Util.inspect(res.Item, false, null));
      return JSON.parse(res.Item.definition);
    })
    .catch(err => {
      console.error(err);

      throw err;
    });
};

const formatQueryStringParameters = (limit = null, paginationToken = null, filtrationQueryStringParameters = []) => {
  // ------------------------------------------
  let res = '';
  let queryStringParametersArray = [];

  if (limit) {
    queryStringParametersArray.push(`limit=${limit}`);
  }

  if (paginationToken) {
    queryStringParametersArray.push(`paginationToken=${paginationToken}`);
  }

  queryStringParametersArray = [...queryStringParametersArray, ...filtrationQueryStringParameters];

  res = (queryStringParametersArray.length > 0) ? `?${queryStringParametersArray.join('&')}` : '';

  return res;
}

// This is a pure function designed to convert a data array into a pagination compatible JSON API response body
// Assumptions:
// 1) The data passed in is an array of JS objects AND is ordered by the key you want to paginate on,
// 2) The ordering of the results mean the top of the page at the first index, the last of the page at the last index
// 3) The pagination_token_key exists at the top level of the flat JS objects (customisation will be required for more complex cases)
// Output:
// The function ouputs a revised JSON payload which includes a 'previous' and 'next' page HATEOAS entry
const generateIntegerPaginationFromArrayData = (params) => {
  // ---------------------------------------------------------------------------- 
  return new Promise((resolve, reject) => {
    console.info("boilerplate.generateIntegerPaginationFromArrayData()");

    let data = params.data;
    let path = params.path;
    let queryStringParameters = params.queryStringParameters;
    let multiValueQueryStringParameters = params.multiValueQueryStringParameters;
    let paginationPointerArray = params.paginationPointerArray;
    let maxLimit = params.maxLimit;
    let order = params.order;
    let count = params.count;
    let countType = params.countType;
    let countFromPageToEnd = params.countFromPageToEnd;
    let isLastPage = params.isLastPage;
    let prevPaginationToken = params.prevPaginationToken;

    console.log(paginationPointerArray);
    console.log(order);
    // This pagination method uses a 'LIMIT OFFSET' pagination method
    // It assumes at this stage that 'data' comprises an array of objects with an embedded pagination token at 'some' level
    // The level of the pagination token can be accessed by traversing through ONLY javascript objects using an array of keys
    let response = {
      data: data
    }

    // Query the limit for this request (or the maximum limit if capped)
    let limit = ((!maxLimit && queryStringParameters && 'limit' in queryStringParameters && queryStringParameters.limit) || (queryStringParameters && 'limit' in queryStringParameters && parseInt(queryStringParameters.limit) < maxLimit)) ? parseInt(queryStringParameters.limit) : maxLimit;
    let paginationToken = (queryStringParameters && 'paginationToken' in queryStringParameters) ? parseInt(queryStringParameters.paginationToken) : null;
    let filtrationQueryStringParamNames = (multiValueQueryStringParameters && Object.keys(multiValueQueryStringParameters).length > 0) ? Object.keys(multiValueQueryStringParameters).filter(queryStringParam => !['limit', 'paginationToken'].includes(queryStringParam)) : [];

    let filtrationQueryStringParameters = [];

    filtrationQueryStringParamNames.forEach(paramName => {
      // -----------------------------
      console.log(paramName);
      multiValueQueryStringParameters[paramName].forEach(paramValue => {
        console.log(paramValue);
        filtrationQueryStringParameters.push(`${paramName}=${encodeURI(paramValue)}`);
      })
    });

    console.log(JSON.stringify(filtrationQueryStringParameters));

    // CONDITIONAL -> Work out whether NEXT/LAST pages are required
    // ---------------------------------------------------------------
    // CASE (1) IF NOT DATA RETURNED FROM QUERY OR LAST PAGE OF RESULSET
    // ---------------------------------------------------------------
    if (data.length <= 0 || (countFromPageToEnd && count <= data.length) || data.length < limit) {
      // -------------
      // Redirect the user to the start of the dataset if no results are returned
      response.links = {
        // For self - just replicate the existing query with maximum limit override if necessary
        self: {
          href: `${path}` + formatQueryStringParameters(limit, paginationToken, filtrationQueryStringParameters)
        },
        // For previous - rely on the correct submission of the previous pagination token from calling method
        prev: {
          href: `${path}` + formatQueryStringParameters(limit, prevPaginationToken, filtrationQueryStringParameters)
        },
        // For next - redirect to the beginning of the dataset (i.e. no pagination token)
        next: {
          href: `${path}` + formatQueryStringParameters(limit, null, filtrationQueryStringParameters)
        },
        pageCount: data.length,
        count: (count) ? count : null,
        countType: countType,
        countFromPageToEnd: countFromPageToEnd,
        isLastPage: true
      };
    } 
    // ---------------------------------------------------------------
    // CASE (2) RETURN STANDARD PAGINATION DEPENDING ON ORDERING
    // ---------------------------------------------------------------
    else {
      // -------------

      // Search for start and end pagination tokens
      let topPageValue = paginationPointerArray.reduce((object, key) => object[key], data[0]);
      let bottomPageValue = paginationPointerArray.reduce((object, key) => object[key], data[(data.length - 1)]);

      let nextPageStart;
      let lastPageStart;

      switch (order) {
        case 'desc': {
          nextPageStart = bottomPageValue;
          lastPageStart = topPageValue + limit + 1;
          break;
        }
        case 'asc': {
          nextPageStart = bottomPageValue;
          lastPageStart = ((topPageValue - limit - 1) > 0) ? topPageValue - limit - 1 : 0;
          break;
        }
        // Default to descending - aim to never reach here though
        default: {
          nextPageStart = bottomPageValue;
          lastPageStart = topPageValue + limit + 1;
          break;
        }
      }

      response.links = {
        self: {
          href: `${path}` + formatQueryStringParameters(limit, paginationToken, filtrationQueryStringParameters)
        },
        prev: {
          href: `${path}` + formatQueryStringParameters(limit, prevPaginationToken, filtrationQueryStringParameters)
        },
        next: {
          href: `${path}`  + formatQueryStringParameters(limit, (nextPageStart > 0) ? nextPageStart : null, filtrationQueryStringParameters)
        },
        pageCount: data.length,
        count: (count || count === 0) ? count : null,
        countType: countType,
        countFromPageToEnd: countFromPageToEnd,
        isLastPage: isLastPage || (countType === 'TOTAL' && nextPageStart === count)
      };
    }
    resolve(response);
  });
};

const getResourcesAndIdentifiers = (serviceName, event) => {
  // ---------------------------------------------------------------------------- 
  return new Promise((resolve, reject) => {
    console.info("boilerplate.getResourcesAndIdentifiers()");

    // This function pulls out all of the resources included within an lambda event path provided from API Gateway
    // It splits the path using '/' and then filters out:
    //    1) the service name, and,
    //    2) any pathParameters that are included (these are currently surrounded by curly braces)

    let resources = event.resource.split('/')
      .filter(pathComponent => { return !['', serviceName].includes(pathComponent) && !/{.+}/.test(pathComponent); })
      .map(pathResources => pathResources.replace(/s$/, ""));

    let identifiers = [];
    for (var pathParam in event.pathParameters) {
      identifiers.push(pathParam);
    }

    resolve({
      resources,
      identifiers,
    });
  });
}

// =============
// EXPORTS
// =============

module.exports = {
  // CLASSES
  ServiceError,
  AuthorisationError,
  ForbiddenError,
  SuspensionError,
  ParameterValidationError,
  DataAccessError,
  NotFoundError,
  // FUNCTIONS
  cognitoGroupAuthCheck,
  validateJSON,
  parseSubSchemas,
  getSchemaFromDynamo,
  generateIntegerPaginationFromArrayData,
  getResourcesAndIdentifiers,
};