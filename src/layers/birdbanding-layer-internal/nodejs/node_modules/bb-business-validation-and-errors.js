'use strict';

// =============
// MODULES
// =============
const Promise = require('bluebird');
const Util = require('util');
const AJV = require('ajv');
const Moment = require('moment');

// Import and configure AWS module
var AWSXRay = require('aws-xray-sdk');
var AWS = AWSXRay.captureAWS(require('aws-sdk'));
AWS.config.setPromisesDependency(require('bluebird'));

// Custom imports from other layers
const Helpers = require('helpers');
const BBSSHelpers = require('./bb-spreadsheet-helpers.js');

// =============
// CONSTS
// =============

const MARK_STATE_TIMELINE_REQUIREMENTS = {
  'NEW': {
    // Required means -> any events before/after, must be from within these sets
    required: {
      before: [],
      after: ['ALLOCATED', 'LOST', 'RETURNED', 'ATTACHED', 'DETACHED', 'PRACTICE', 'RETURNED_USED', 'OTHER']
    },
    // Preferred means -> a warning will result if immediate before/after event does not fall within these sets
    preferred: {
      before: [],
      after: []
    }
  },
  'ALLOCATED': {
    required: {
      before: ['NEW', 'RETURNED', 'LOST', 'ALLOCATED'],
      after: ['ALLOCATED', 'LOST', 'RETURNED', 'ATTACHED', 'DETACHED', 'PRACTICE', 'RETURNED_USED', 'OTHER']
    },
    preferred: {
      before: ['NEW', 'RETURNED', 'LOST', 'ALLOCATED'],
      after: ['LOST', 'RETURNED', 'ATTACHED', 'PRACTICE', 'OTHER']
    }
  },
  'LOST': {
    required: {
      before: ['NEW', 'ALLOCATED', 'LOST', 'RETURNED', 'ATTACHED', 'DETACHED', 'PRACTICE', 'RETURNED_USED'],
      after: ['ALLOCATED', 'LOST', 'RETURNED', 'ATTACHED', 'DETACHED', 'PRACTICE', 'RETURNED_USED', 'OTHER']
    },
    preferred: {
      before: ['NEW', 'RETURNED', 'ALLOCATED', 'PRACTICE', 'DETACHED', 'RETURNED_USED'],
      after: ['ALLOCATED', 'RETURNED_USED']
    }
  },
  'RETURNED': {
    required: {
      before: ['NEW', 'ALLOCATED', 'LOST', 'RETURNED', 'ATTACHED', 'DETACHED', 'PRACTICE', 'RETURNED_USED'],
      after: ['LOST', 'OTHER']
    },
    preferred: {
      before: ['ALLOCATED'],
      after: ['ALLOCATED', 'LOST']
    }
  },
  'ATTACHED': {
    required: {
      before: ['NEW', 'ATTACHED', 'ALLOCATED', 'LOST', 'RETURNED'],
      after: ['ATTACHED', 'DETACHED', 'LOST', 'RETURNED_USED', 'OTHER']
    },
    preferred: {
      before: ['ALLOCATED', 'ATTACHED'],
      after: ['ATTACHED', 'DETACHED']
    }
  },
  'DETACHED': {
    required: {
      before: ['NEW', 'ATTACHED', 'ALLOCATED', 'LOST', 'RETURNED'],
      after: ['LOST', 'RETURNED_USED', 'OTHER']
    },
    preferred: {
      before: ['ATTACHED'],
      after: ['LOST', 'RETURNED_USED', 'OTHER']
    }
  },
  'PRACTICE': {
    required: {
      before: ['NEW', 'ALLOCATED', 'LOST', 'RETURNED'],
      after: ['LOST', 'RETURNED_USED', 'OTHER']
    },
    preferred: {
      before: ['ALLOCATED'],
      after: ['RETURNED_USED', 'LOST', 'OTHER']
    }
  },
  'RETURNED_USED': {
    required: {
      before: ['NEW', 'ALLOCATED', 'LOST', 'RETURNED', 'ATTACHED', 'DETACHED', 'PRACTICE', 'RETURNED_USED'],
      after: ['OTHER', 'LOST']
    },
    preferred: {
      before: ['DETACHED', 'LOST', 'PRACTICE'],
      after: ['LOST', 'OTHER']
    }
  },
  'OTHER': {
    required: {
      before: ['NEW', 'ALLOCATED', 'LOST', 'RETURNED', 'ATTACHED', 'DETACHED', 'PRACTICE', 'RETURNED_USED'],
      after: []
    },
    preferred: {
      before: ['ALLOCATED', 'PRACTICE', 'RETURNED_USED', 'DETACHED'],
      after: []
    }
  }
};

// =============
// CLASSES
// =============
class CustomError {

  constructor(code, type, severity, keyword, message, property, value) {

    // Populate the main properties
    this.code = code || 0;
    this.type = type || 'UnexpectedError';
    this.severity = severity || 'CRITICAL';
    this.message = message || 'An unknown error has occurred!';
    this.keyword = keyword || 'UNEXPECTED';
    this.property = property || '';
    this.value = value || 'Please contact support';
  }
}

class CustomErrorFactory {
  constructor(CustomErrors = []) {
    this.CustomErrors = CustomErrors;
  }

  getError(name, errorParams=[]) {
// ----------------------------------------------------------------------------
    console.info("CustomErrorFactory.getError() -> " + name);

    if (this.CustomErrors.length === 0) {
      throw new Error('Custom error list has not been populated...');
    }
    // Find the error definition/template we need
    let error = this.CustomErrors[name];

    // Substitute the parameters for the tokens
    console.log(error);
    let { code, type, severity, 
          message, keyword,
          value, property }  = error;
    if (errorParams) {
      errorParams.forEach((param, i) => {
        let token = "{" + i + "}";
        code = (typeof code === 'string' && code.includes(token)) ? param : code;
        severity = Helpers.replaceAll(severity, token, param);
        message = Helpers.replaceAll(message, token, param);
        keyword = Helpers.replaceAll(keyword, token, param);
        value = Helpers.replaceAll(value, token, param);
        property = Helpers.replaceAll(property, token, param);
      });
    }
    return new CustomError(code, type, severity, keyword, message, property, value);
  }
}

// =============
// FUNCTIONS
// =============

// ----------------------
// General Error Helpers
// ----------------------

const AddErrorToParent = (error, parentErrorObject, level1, level2) => {
  // ----------------------------------------
  parentErrorObject[level1] = parentErrorObject[level1] || {};
  parentErrorObject[level1][level2] = parentErrorObject[level1][level2] || [];
  parentErrorObject[level1][level2].push(error);

  return parentErrorObject;
}

//  -> Required property missing
const getRequiredNestedPropertySpreadsheetReferences = (schemaError, eventBatch, mappingSchema) => {
  // ----------------------------------------------------
  let ref = {};

  // Get ss-column letter reference
  let { missingProperty } = schemaError.data.params;
  ref.recordProp = (typeof mappingSchema.col_mapping[missingProperty] !== 'undefined') ? mappingSchema.col_mapping[missingProperty] : missingProperty;

  // Get ss-row numeric reference (temporarily stored in the event for use during validation)
  let parsedDataPath = schemaError.data.path.replace(/["']/g, "").split('/');
  let processedEventIndex = parseInt(parsedDataPath[1]);
  ref.record = eventBatch.events[processedEventIndex].metadata.eventIndex;

  return ref;
}

//  -> Invalid type
const getSpecificPropertySpreadsheetReferences = (schemaError, eventBatch, mappingSchema) => {
  // ----------------------------------------------------
  let ref = {};

  // Get ss-row numeric reference (temporarily stored in the event for use during validation)
  let parsedDataPath = schemaError.data.path.replace(/["']/g, "").split('/');
  let processedEventIndex = parseInt(parsedDataPath[1]);
  let errorProperty = (parsedDataPath.length === 5) ? `${parsedDataPath[2] + '_' + parsedDataPath[parsedDataPath.length - 1] + '_' + (parseInt(parsedDataPath[3]) + 1)}` : parsedDataPath[parsedDataPath.length - 1];
  errorProperty = (errorProperty.includes('mark_state')) ? `${parsedDataPath[2] + '_' + parsedDataPath[parsedDataPath.length - 1]}` : errorProperty;
  let characteristicNumber = (parsedDataPath.includes('characteristic_measurements')) ? (parseInt(parsedDataPath[3]) + 1) : '';
  errorProperty = (parsedDataPath.includes('characteristic_measurements')) ? 
        `characteristic_${(parsedDataPath.includes('value')) ? 'value' : 'detail'}_${characteristicNumber}` : errorProperty;

  ref.record = eventBatch.events[processedEventIndex].metadata.eventIndex;
  ref.recordProp = mappingSchema.col_mapping[errorProperty];

  return ref;
}

// ----------------------
// Schema Validations
// ----------------------
const PostProcessIndividualSchemaError = (CustomErrors, eventBatch, mappingSchema, schemaError) => {
  
  switch (schemaError.data.keyword) {
    // -------------------------------------
    case 'required': {
      // -------------------------------------
      let ref = getRequiredNestedPropertySpreadsheetReferences(schemaError, eventBatch, mappingSchema);
      let { missingProperty } = schemaError.data.params;
      let mappedProperty = mappingSchema.properties[missingProperty] || mappingSchema.backTranslationProperties[missingProperty] || missingProperty;
      // 100
      return {
        ...ref,
        error: CustomErrorFactory.getError(CustomErrors, 'PropertyRequiredError', [mappedProperty, ref.record])
      }
    }
    case 'type': {
      // -------------------------------------
      let ref = getSpecificPropertySpreadsheetReferences(schemaError, eventBatch, mappingSchema)
      let parsedDataPath = schemaError.data.path.replace(/["']/g, "").split('/');
      let processedEventIndex = parseInt(parsedDataPath[1]);
      let subObjectKey = parsedDataPath[2];
      let errorProperty = parsedDataPath[parsedDataPath.length - 1];
      errorProperty = (parsedDataPath.includes('characteristic_measurements')) ? 
      `characteristic_${(parsedDataPath.includes('value')) ? 'value' : 'detail'}_${(parseInt(parsedDataPath[3]) + 1)}` : errorProperty;
      let errorValue = eventBatch.events[processedEventIndex][subObjectKey][errorProperty];
      let allowableTypes = schemaError.data.params.type.replace(/[,]/, ', ');
      let mappedProperty = mappingSchema.properties[errorProperty] || mappingSchema.backTranslationProperties[errorProperty] || errorProperty;
      // 101
      return {
        ...ref,
        error: CustomErrorFactory.getError(CustomErrors, 'PropertyTypeRequired', [mappedProperty, errorValue, ref.record, allowableTypes])
      }
    }
    case 'enum': {
      // -------------------------------------
      let ref = getSpecificPropertySpreadsheetReferences(schemaError, eventBatch, mappingSchema)
      let parsedDataPath = schemaError.data.path.replace(/["']/g, "").split('/');
      let processedEventIndex = parseInt(parsedDataPath[1]);
      let subObjectKey = parsedDataPath[2];
      let errorProperty = (parsedDataPath.length === 5) ? `${parsedDataPath[2] + '_' + parsedDataPath[parsedDataPath.length - 1]}` : parsedDataPath[parsedDataPath.length - 1];
      let errorValue = eventBatch.events[processedEventIndex][subObjectKey][errorProperty];

      let allowableValues = schemaError.data.params.allowedValues.join(',');
      let mappedProperty = mappingSchema.properties[errorProperty] || mappingSchema.backTranslationProperties[errorProperty] || errorProperty;
      // 102
      return {
        ...ref,
        error: CustomErrorFactory.getError(CustomErrors, 'PropertyEnumError', [mappedProperty, errorValue, ref.record, allowableValues]) 
      }
    }
    case 'minimum':
    case 'maximum': {
      // -------------------------------------
      let ref = getSpecificPropertySpreadsheetReferences(schemaError, eventBatch, mappingSchema)
      let limitType = schemaError.data.keyword;
      let parsedDataPath = schemaError.data.path.replace(/["']/g, "").split('/');
      let processedEventIndex = parseInt(parsedDataPath[1]);
      let subObjectKey = parsedDataPath[2];
      let errorProperty = parsedDataPath[parsedDataPath.length - 1];
    
      let errorValue = eventBatch.events[processedEventIndex][subObjectKey][errorProperty];
    
      let limitValue = schemaError.data.params.limit;
      let code = limitType === 'minimum' ? 103 : 104;
      let mappedProperty = mappingSchema.properties[errorProperty] || mappingSchema.backTranslationProperties[errorProperty] || errorProperty;
      let title = limitType === 'minimum' ? 'Value Below Minimum' : 'Value Above Maximum';
      let messageAndHelperLimitText1 = limitType === 'minimum' ? 'below' : 'above';
      let messageAndHelperLimitText2 = limitType === 'minimum' ? 'above' : 'below';

      // 103 and 104
      return {
        ...ref,
        error: CustomErrorFactory.getError(CustomErrors, 'PropertyLimitViolation', [code, mappedProperty, title, errorValue, ref.record, messageAndHelperLimitText1, limitType, messageAndHelperLimitText2, limitValue]) 
      }
    }
    case 'format': {
      // -------------------------------------
      let ref = getSpecificPropertySpreadsheetReferences(schemaError, eventBatch, mappingSchema)
      let parsedDataPath = schemaError.data.path.replace(/["']/g, "").split('/');

      let processedEventIndex = parseInt(parsedDataPath[1]);
      let subObjectKey = parsedDataPath[2];
      let subObjectIndex = (parsedDataPath.length === 5) ? parseInt(parsedDataPath[3]) : null;
      
      let errorProperty = (parsedDataPath.length === 5) ? `${parsedDataPath[2] + '_' + parsedDataPath[parsedDataPath.length - 1] + '_' + (parsedDataPath[3] + 1)}` : parsedDataPath[parsedDataPath.length - 1];
      let characteristicNumber = (parsedDataPath.includes('characteristic_measurements')) ? (parseInt(parsedDataPath[3]) + 1) : '';
      errorProperty = (parsedDataPath.includes('characteristic_measurements')) ? 
            `characteristic_${(parsedDataPath.includes('value')) ? 'value' : 'detail'}_${characteristicNumber}` : errorProperty;

      let errorKey = parsedDataPath[parsedDataPath.length - 1];

      let errorValue = (parsedDataPath.length === 5) ? eventBatch.events[processedEventIndex][subObjectKey][subObjectIndex][errorKey] : eventBatch.events[processedEventIndex][subObjectKey][errorProperty];
      let mappedProperty = mappingSchema.properties[errorProperty] || mappingSchema.backTranslationProperties[errorProperty] || errorProperty;

      // Special handling for date case...
      let format;
      switch (schemaError.data.params.format) {
        case 'date-time': { format = 'dd/mm/yyyy [hh:mm optional 24 hour time]'; break; }
        default: { format = schemaError.data.params.format; break; }
      }
      // 105
      return {
        ...ref,
        error: CustomErrorFactory.getError(CustomErrors, 'PropertyFormatError', [mappedProperty, errorValue, ref.record, format])
      }
    }
    case 'if': {
      // -------------------------------------
      console.info('If issue captured by more specific violation - bypassing this schema error')
      return null;
    }
    default: {
      // We aren't expecting any other schema error types to come through (unless the spreadseheet has been severely tampered with)
      // In this case is probably best to get in touch with the Banding Office,
      // Either:
      // 1) We can review the error and attempt to fix if it's our mistake, or,
      // 2) We can provide a clean version of the spreadsheet and explain the requirements of data format when submitting
      console.error(schemaError);
      return {
        record: null,
        recordProp: null,
        error: CustomErrorFactory.getError(CustomErrors, 'ValidationProcessError', [schemaError])
      }
    }
  }
}

// ----------------------
// Business Validations
// ----------------------

// DUPLICATE VALIDATION
// ---------------------
const DuplicateValidation = (CustomErrors, eventBatch, lookupData, mappingSchema, businessErrors) => {
  // ----------------------------------------------------      
  return new Promise((resolve, reject) => {

    console.info("BBBusinessValidationAndErrors.DuplicateValidation()");

    let duplicateErrors = businessErrors;

    try {

      eventBatch.events.forEach((event, outerIndex) => {
        // -------------------------------------------------
        // -----------------------------
        //  Duplicate Check - Submission Event Batch
        // -----------------------------
        // -> Note: only check this for bird records only
        let batchInternalDuplicate = eventBatch.events.find((duplicateCandidate, innerIndex) =>
          outerIndex !== innerIndex &&
          BBSSHelpers.IsBirdEvent(event.event.event_type) &&
          duplicateCandidate.event.event_type === event.event.event_type &&
          Moment(duplicateCandidate.event.event_timestamp).isSame(Moment(event.event.event_timestamp)) &&
          duplicateCandidate.event.event_provider_id === event.event.event_provider_id &&
          duplicateCandidate.event.event_reporter_id === event.event.event_reporter_id &&
          ((duplicateCandidate.event.latitude === event.event.latitude && duplicateCandidate.event.longitude === event.event.longitude) ||
            (duplicateCandidate.event.user_northing === event.event.user_northing && duplicateCandidate.event.user_easting === event.event.user_easting)) &&
          duplicateCandidate.bird.id === event.bird.id);

        if (typeof batchInternalDuplicate !== 'undefined') {
          let ref = {
            record: event.metadata.eventIndex,
            recordProp: null // Duplicate error is most appropriately expressed row-wise...
          }
          let errorProperties = [
            'prefix_number', 'short_number',
            'event_type', 'event_timestamp', 'event_provider_id',
            'event_reporter_id', 'latitude', 'longitude', 'user_northing', 'user_easting'];
          let mappedProperties = errorProperties.map(errorProp => mappingSchema.properties[errorProp] || mappingSchema.backTranslationProperties[errorProp] || errorProp).join(', ');
          let type = 'upload batch';
          let eventReference = `record: ${batchInternalDuplicate.metadata.eventIndex}`;

          let error = CustomErrorFactory.getError(CustomErrors, 'DuplicateRecordError', [mappedProperties, ref.record, eventReference, type]);
          duplicateErrors = AddErrorToParent(error, duplicateErrors, ref.record, 'ss_duplicate');
        }


        // -----------------------------
        //  Duplicate Check - Database
        // -----------------------------
        // -> Note: only check this for bird records only
        console.info('Duplicate validation....');

        let duplicate = lookupData.duplicateEventCandidates.find(duplicateCandidate => {
          return(
              duplicateCandidate.event_type === event.event.event_type &&
              BBSSHelpers.IsBirdEvent(event.event.event_type) &&
              Moment(duplicateCandidate.event_timestamp).isSame(Moment(event.event.event_timestamp)) &&
              duplicateCandidate.event_provider_id === event.event.event_provider_id &&
              duplicateCandidate.event_reporter_id === event.event.event_reporter_id &&
              ((parseFloat(duplicateCandidate.latitude) === event.event.latitude && parseFloat(duplicateCandidate.longitude) === event.event.longitude) ||
                (parseFloat(duplicateCandidate.user_northing) === event.event.user_northing && parseFloat(duplicateCandidate.user_easting) === event.event.user_easting)) &&
              duplicateCandidate.bird_id === event.bird.id
          )
        });

        if (typeof duplicate !== 'undefined') {
          let ref = {
            record: event.metadata.eventIndex,
            recordProp: null // Duplicate error is most appropriately expressed row-wise...
          }
          let errorProperties = [
            'prefix_number', 'short_number',
            'event_type', 'event_timestamp', 'event_provider_id',
            'event_reporter_id', 'latitude', 'longitude', 'user_northing', 'user_easting'];
          let mappedProperties = errorProperties.map(errorProp => mappingSchema.properties[errorProp] || mappingSchema.backTranslationProperties[errorProp] || errorProp).join(', ');
          let type = 'database';
          let eventReference = `event: ${duplicate.id}`;

          let error = CustomErrorFactory.getError(CustomErrors, 'DuplicateRecordError', [mappedProperties, ref.record, eventReference, type]);
          duplicateErrors = AddErrorToParent(error, duplicateErrors, ref.record, 'duplicate');
        }
      });

      resolve(duplicateErrors);
    }
    catch (error) {
      reject(error);
    }
  });
}


// BANDER CERTIFICATION VALIDATION
// ---------------------
const BanderCertificationValidation = (CustomErrors, eventBatch, lookupData, mappingSchema, businessErrors) => {
  // ----------------------------------------------------      
  return new Promise((resolve, reject) => {

    console.info("BBBusinessValidationAndErrors.BanderCertificationValidation()");

    // Validation Config
    let certificationHieracy = ['L3', 'HIST', 'L2', 'L1', ''];

    let banderCertificationErrors = businessErrors;

    try {

      eventBatch.events.forEach(event => {
        // -------------------------------------------------
        // If event_provider_id assigned, compelete verification of the required certification level (i.e. L3)
        // In future this check may require modification to be species specific! But not now... phew
        if (typeof event.event.event_provider_id !== 'undefined' && event.event.event_provider_id) {
          let bander = lookupData.banders.find(bander => bander.id === event.event.event_provider_id);

          let certificationLevel = bander.bander_certifications.reduce((maximumCertificationLevel, certification) => {
            return (certificationHieracy.indexOf(certification.competency_level) < certificationHieracy.indexOf(maximumCertificationLevel)) ?
              certification.competency_level : maximumCertificationLevel;
          }, '');

          // Final sweep to check if the bander is a 'historic bander' with a pseudo-certification provided during migration
          if (['L2', 'L1', ''].includes(certificationLevel) && bander.nznbbs_certification_number.includes('H')){
            certificationLevel = 'HIST';
          }

          if (!['L3', 'HIST'].includes(certificationLevel)) {
            let ref = {
              record: event.metadata.eventIndex,
              recordProp: mappingSchema.col_mapping['event_provider_id']
            };
            let errorProperty = 'event_provider_id';
            let mappedProperty = mappingSchema.properties[errorProperty] || mappingSchema.backTranslationProperties[errorProperty] || errorProperty;

            let error = CustomErrorFactory.getError(CustomErrors, 'BanderCertificationError', [mappedProperty, ref.record, 'L3']);
            banderCertificationErrors = AddErrorToParent(error, banderCertificationErrors, ref.record, ref.recordProp);
          }
        }

        // If event_reporter_id assigned, compelete verification of the required certification level (i.e. L1)
        // In future this check may require modification to be species specific! But not now... phew
        if (typeof event.event.event_reporter_id !== 'undefined' && event.event.event_reporter_id) {
          let bander = lookupData.banders.find(bander => bander.id === event.event.event_reporter_id);

          let certificationLevel = bander.bander_certifications.reduce((maximumCertificationLevel, certification) => {
            return (certificationHieracy.indexOf(certification.competency_level) < certificationHieracy.indexOf(maximumCertificationLevel)) ?
              certification.competency_level : maximumCertificationLevel;
          }, '');

          // Final sweep to check if the bander is a 'historic bander' with a pseudo-certification provided during migration
          if (['L2', 'L1', ''].includes(certificationLevel) && bander.nznbbs_certification_number.includes('H')){
            certificationLevel = 'HIST';
          }

          if (!['L3', 'HIST', 'L2', 'L1'].includes(certificationLevel)) {
            let ref = {
              record: event.metadata.eventIndex,
              recordProp: mappingSchema.col_mapping['event_reporter_id']
            };
            let errorProperty = 'event_reporter_id';
            let mappedProperty = mappingSchema.properties[errorProperty] || mappingSchema.backTranslationProperties[errorProperty] || errorProperty;

            let error = CustomErrorFactory.getError(CustomErrors, 'BanderCertificationError', [mappedProperty, ref.record, 'Bander']);
            banderCertificationErrors = AddErrorToParent(error, banderCertificationErrors, ref.record, ref.recordProp);
          }
        }
      });

      resolve(banderCertificationErrors);
    }
    catch (error) {
      reject(error);
    }
  });
}

const MarkStateTimelineValidation = (CustomErrors, eventBatch, lookupData, mappingSchema, businessErrors) => {
  // ----------------------------------------------------      
  return new Promise((resolve, reject) => {

    console.info("BBBusinessValidationAndErrors.MarkStateTimelineValidation()");

    // Validation Config
    let markStateRequirements = MARK_STATE_TIMELINE_REQUIREMENTS;

    let markStateTimelineErrors = businessErrors;

    try {

      // We are aiming to do both:
      // 1) Warnings (for out-of-sequence timelines), and,
      // 2) Critical errors (for invalidations of a marks timeline)

      eventBatch.events.forEach(event => {

        let eventTimestamp = Moment(event.event.event_timestamp);

        event.mark_state.forEach(markState => {
          // ---------------------------------
          // For each mark, construct the lookup data timeline
          let markLookup = lookupData.marks.find(mark => mark.id === markState.mark_id);
          let markStateBefore = (typeof markLookup !== 'undefined' && markLookup) ? markLookup.mark_state.filter(markState => Moment(markState.event.event_timestamp).isBefore(eventTimestamp)) : [];
          let markStateImmediatelyBefore = (markStateBefore.length > 0) ? markStateBefore.reduce((latestMarkState, markState) => { return (!latestMarkState || Moment(markState.event.event_timestamp).isAfter(Moment(latestMarkState.event.event_timestamp)) ? markState : latestMarkState) }, null) : null;
          let markStateAfter = (typeof markLookup !== 'undefined' && markLookup) ? markLookup.mark_state.filter(markState => Moment(markState.event.event_timestamp).isAfter(eventTimestamp)) : [];
          let markStateImmediatelyAfter = (markStateAfter.length > 0) ? markStateAfter.reduce((earliestMarkState, markState) => { return (!earliestMarkState || Moment(markState.event.event_timestamp).isBefore(Moment(earliestMarkState.event.event_timestamp)) ? markState : earliestMarkState) }, null) : null;

          // Validation of these lookup event_type
          let eventTimelineRequirements = markStateRequirements[markState.state];

          markStateBefore.forEach(markStateBefore => {
            if (!eventTimelineRequirements.required.before.includes(markStateBefore.state)) {
              // Error!
              let ref = {
                record: event.metadata.eventIndex,
                recordProp: mappingSchema.col_mapping['event_timestamp']
              };
              let criticality = 'CRITICAL';
              let title = 'Invalid Mark State Timeline'
              let markStateRequirementsMessage = eventTimelineRequirements.required.before.join(', ');
              let errorProperty = 'event_timestamp';
              let mappedProperty = mappingSchema.properties[errorProperty] || mappingSchema.backTranslationProperties[errorProperty] || errorProperty;
              let referenceMarkState = { ...markState, prefix_number: markLookup.prefix_number, short_number: markLookup.short_number }

              let error = CustomErrorFactory.getError(CustomErrors, 'MarkStateTimelineError', 
                                                        [criticality, mappedProperty, 
                                                          title, ref.record, 
                                                          referenceMarkState.prefix_number, referenceMarkState.short_number, 
                                                          'will invalidate the band timeline', 'can only', markStateRequirementsMessage, 
                                                          'immediately before', referenceMarkState.state, 'error',
                                                            mappingSchema.properties['event_type']]); 
              markStateTimelineErrors = AddErrorToParent(error, markStateTimelineErrors, ref.record, ref.recordProp);

            }
          });

          markStateAfter.forEach(markStateAfter => {
            if (!eventTimelineRequirements.required.after.includes(markStateAfter.state)) {
              // Error!
              let ref = {
                record: event.metadata.eventIndex,
                recordProp: mappingSchema.col_mapping['event_timestamp']
              };
              let criticality = 'CRITICAL';
              let title = 'Invalid Mark State Timeline'
              let markStateRequirementsMessage = eventTimelineRequirements.required.after.join(', ');
              let errorProperty = 'event_timestamp';
              let mappedProperty = mappingSchema.properties[errorProperty] || mappingSchema.backTranslationProperties[errorProperty] || errorProperty;
              let referenceMarkState = { ...markState, prefix_number: markLookup.prefix_number, short_number: markLookup.short_number }

              let error = CustomErrorFactory.getError(CustomErrors, 'MarkStateTimelineError',
                                                        [criticality, mappedProperty, 
                                                          title, ref.record, 
                                                          referenceMarkState.prefix_number, referenceMarkState.short_number, 
                                                          'will invalidate the band timeline', 'can only', markStateRequirementsMessage, 
                                                          'immediately after', referenceMarkState.state, 'error',
                                                            mappingSchema.properties['event_type']]) 
              markStateTimelineErrors = AddErrorToParent(error, markStateTimelineErrors, ref.record, ref.recordProp);
            }
          });

          // WARNINGS
          if (markStateImmediatelyBefore && !eventTimelineRequirements.preferred.before.includes(markStateImmediatelyBefore.state)) {
            let ref = {
              record: event.metadata.eventIndex,
              recordProp: mappingSchema.col_mapping['event_timestamp']
            };
            let criticality = 'WARN';
            let title = 'Incomplete Mark State Timeline'
            let markStateRequirementsMessage = eventTimelineRequirements.preferred.before.join(', ');
            let errorProperty = 'event_timestamp';
            let mappedProperty = mappingSchema.properties[errorProperty] || mappingSchema.backTranslationProperties[errorProperty] || errorProperty;
            let referenceMarkState = { ...markState, prefix_number: markLookup.prefix_number, short_number: markLookup.short_number }

            let error = CustomErrorFactory.getError(CustomErrors, 'MarkStateTimelineError',
                                                      [criticality, mappedProperty, 
                                                        title, ref.record, 
                                                        referenceMarkState.prefix_number, referenceMarkState.short_number, 
                                                        'does not form a complete band timeline, some events may be missing', 'should', markStateRequirementsMessage, 
                                                        'before', referenceMarkState.state, 'warning',
                                                          mappingSchema.properties['event_type']]) 
            markStateTimelineErrors = AddErrorToParent(error, markStateTimelineErrors, ref.record, ref.recordProp);
          }

          if (markStateImmediatelyAfter && !eventTimelineRequirements.preferred.after.includes(markStateImmediatelyAfter.state)) {
            let ref = {
              record: event.metadata.eventIndex,
              recordProp: mappingSchema.col_mapping['event_timestamp']
            };
            let criticality = 'WARN';
            let title = 'Incomplete Mark State Timeline'
            let markStateRequirementsMessage = eventTimelineRequirements.preferred.after.join(', ');
            let errorProperty = 'event_timestamp';
            let mappedProperty = mappingSchema.properties[errorProperty] || mappingSchema.backTranslationProperties[errorProperty] || errorProperty;
            let referenceMarkState = { ...markState, prefix_number: markLookup.prefix_number, short_number: markLookup.short_number }

            let error = CustomErrorFactory.getError(CustomErrors, 'MarkStateTimelineError',
                                                      [criticality, mappedProperty, 
                                                        title, ref.record, 
                                                        referenceMarkState.prefix_number, referenceMarkState.short_number, 
                                                        'does not form a complete band timeline, some events may be missing', 'should', markStateRequirementsMessage, 
                                                        'after', referenceMarkState.state, 'warning',
                                                          mappingSchema.properties['event_type']]) 
            markStateTimelineErrors = AddErrorToParent(error, markStateTimelineErrors, ref.record, ref.recordProp);
          }
        });
      });
      resolve(markStateTimelineErrors);
    }
    catch (error) {
      reject(error);
    }
  });
}

// STOCK VALIDATION
// ------------------------
const StockEventValidation = (CustomErrors, eventBatch, lookupData, mappingSchema, businessErrors) => {
  // ----------------------------------------------------      
  return new Promise((resolve, reject) => {

    console.info("BBBusinessValidationAndErrors.StockEventValidation()");

    let stockValidationErrors = businessErrors;

    // Validation Config
    let certificationHieracy = ['L3', 'L2', 'L1', ''];

    try {

      eventBatch.events.forEach(event => {
        // ------------------------------------------------------
        // If the event is a stock event, complete stock event validation
        if (BBSSHelpers.IsStockEvent(event.event.event_type)) {
          // ----------------------------------------------------------
          // Stock Validations
          // 1) Validate that band exists (as long as it's not a NEW_MARK event)
          //    -> a mark_state will exist if the mark exists in the database
          if (event.event.event_type !== 'NEW_MARK' && event.mark_state.length <= 0) {
            // --------------------------------------------------------------------
            // Attribute error to prefix number and refer to short_number in error messaging
            let ref = {
              record: event.metadata.eventIndex,
              recordProp: mappingSchema.col_mapping['prefix_number']
            };
            let errorProperties = [
              'prefix_number', 'short_number'
            ];
            let mappedProperties = errorProperties.map(errorProp => mappingSchema.properties[errorProp] || mappingSchema.backTranslationProperties[errorProp] || errorProp).join(', ');
            
            let error = CustomErrorFactory.getError(CustomErrors, 'MarkDoesNotExistError', [mappedProperties, event.event.event_type, ref.record, event.metadata.primaryMark])
            stockValidationErrors = AddErrorToParent(error, stockValidationErrors, ref.record, ref.recordProp);
          }

          // 2) The event provider (L3) for any stock events must be the bands most recent 'allocatee'
          // -> This prevents users from manipulating others stock without permission
          if (event.event.event_owner_id !== event.event.event_provider_id) {
            // --------------------------------------------------------------------
            let ref = {
              record: event.metadata.eventIndex,
              recordProp: mappingSchema.col_mapping['event_provider_id']
            };
            let errorProperty = 'event_provider_id';
            let mappedProperty = mappingSchema.properties[errorProperty] || mappingSchema.backTranslationProperties[errorProperty] || errorProperty;

            let error = CustomErrorFactory.getError(CustomErrors, 'UnexpectedStockManipulation', [mappedProperty, event.event.event_type, ref.record, event.metadata.primaryMark, event.event.event_provider_id])
            stockValidationErrors = AddErrorToParent(error, stockValidationErrors, ref.record, ref.recordProp);
          }

          // 3) The allocatee (mark_allocation.bander_id) in a transfer event must be an L3 (i.e. their maximum certification level must be L3)
          if (event.event.event_type === 'TRANSFER') {
            // --------------------------------------------------------------------
            // For each mark allocation in a transfer event, complete certification level validations
            event.mark_allocation.forEach(markAllocation => {
              // --------------------------------------
              let allocatee = lookupData.banders.find(bander => bander.id === markAllocation.bander_id);

              let allocateeCertificationLevel = (typeof allocatee !== 'undefined' && allocatee && allocatee.bander_certifications.length > 0) ?
                  allocatee.bander_certifications.reduce((maximumCertificationLevel, certification) => {
                    return (certificationHieracy.indexOf(certification.competency_level) < certificationHieracy.indexOf(maximumCertificationLevel)) ?
                      certification.competency_level : maximumCertificationLevel;
                  }, '')
                  : '';

              if (!['L3'].includes(allocateeCertificationLevel)) {
                let ref = {
                  record: event.metadata.eventIndex,
                  recordProp: null
                };
                let error = CustomErrorFactory.getError(CustomErrors, 'L3TransferCertificationError', []);
                stockValidationErrors = AddErrorToParent(error, stockValidationErrors, ref.record, "transfer_error");
              }
            });
          }

          // 4) A new_mark must not already exist in the system
          if (event.event.event_type === 'NEW_MARK') {
            // --------------------------------------------------------------------
            let markSplit = event.metadata.primaryMark ? event.metadata.primaryMark.split('-') : [];
            if (markSplit.length === 2) {
              let rawPrefixNumber = markSplit[0];
              let rawShortNumber = markSplit[1];
              // Lookup the mark in the lookup data, if present, there is an error because we think this is a new mark...
              var mark = lookupData.marks.find(obj => (obj.prefix_number === rawPrefixNumber && obj.short_number === rawShortNumber));
              // ----------------------------------
              if (typeof mark !== 'undefined' || !mark) {
                let ref = {
                  record: event.metadata.eventIndex,
                  recordProp: mappingSchema.col_mapping['prefix_number']
                };
                let mappedProperties = errorProperties.map(errorProp => mappingSchema.properties[errorProp] || mappingSchema.backTranslationProperties[errorProp] || errorProp).join(', ');

                let error = CustomErrorFactory.getError(CustomErrors, 'MarkAlreadyExistsError', [mappedProperties, event.event.event_type, ref.record, event.metadata.primaryMark])
                stockValidationErrors = AddErrorToParent(error, stockValidationErrors, ref.record, ref.recordProp);
              }
            }
          }
        }
      });
      resolve(stockValidationErrors);
    }
    catch (error) {
      reject(error);
    }
  });
}

// BIRD VALIDATION
// ------------------------
// -> Event Subobject
const BirdEventValidation = (CustomErrors, eventBatch, lookupData, mappingSchema, businessErrors) => {
  // ----------------------------------------------------
  return new Promise((resolve, reject) => {

    console.info("BBBusinessValidationAndErrors.BirdEventValidation()");

    let birdEventValidationErrors = businessErrors;

    try {

      eventBatch.events.forEach(event => {
        // ------------------------------------------------------
        // If the event is a bird event, complete bird -> event validation
        if (BBSSHelpers.IsBirdEvent(event.event.event_type)) {
          // ----------------------------------------------------------
          // Bird Event Validations
          let subjectEventTimestamp = Moment(event.event.event_timestamp);
          let lookupBird;
          let firstMarkingEventSearch;
          let afterEventList;
          let beforeEventList;

          if (typeof event.bird.id !== 'undefined' && event.bird.id) {
            // 1) Validate that for first_marking_in_hand that no existing no bird exists
            // If a bird-id has been assigned, the mark<->bird relation exists and needs to be checked to confirm no other first marking events exist
            lookupBird = lookupData.birds.find(lookupBird => lookupBird.id === event.bird.id);
            firstMarkingEventSearch = lookupBird.event.find(lookupEvent => lookupEvent.event_type === 'FIRST_MARKING_IN_HAND');
            afterEventList = lookupBird.event.filter(lookupEvent => { 
              return Moment(lookupEvent.event_timestamp).isAfter(subjectEventTimestamp) });
            beforeEventList = lookupBird.event.filter(lookupEvent => Moment(lookupEvent.event_timestamp).isBefore(subjectEventTimestamp));

            if (typeof firstMarkingEventSearch !== 'undefined' && event.event.event_type === 'FIRST_MARKING_IN_HAND') {
              // -------------------------------------
              let ref = {
                record: event.metadata.eventIndex,
                recordProp: mappingSchema.col_mapping['event_type']
              }
              let errorProperty = 'event_type';
              let mappedProperty = mappingSchema.properties[errorProperty] || mappingSchema.backTranslationProperties[errorProperty] || errorProperty;

              let error = CustomErrorFactory.getError(CustomErrors, 'BirdAlreadyHasFirstMarking', [mappedProperty, event.event.event_type, ref.record, event.metadata.primaryMark, firstMarkingEventSearch.id])
              birdEventValidationErrors = AddErrorToParent(error, birdEventValidationErrors, ref.record, ref.recordProp);
            }
            else if (typeof firstMarkingEventSearch === 'undefined' && event.event.event_type !== 'FIRST_MARKING_IN_HAND') {
              // -------------------------------------
              console.info('In-hand event for existing bird, but no first marking event found for it');
              let ref = {
                record: event.metadata.eventIndex,
                recordProp: mappingSchema.col_mapping['event_type']
              }
              let errorProperty = 'event_type';
              let mappedProperty = mappingSchema.properties[errorProperty] || mappingSchema.backTranslationProperties[errorProperty] || errorProperty;

              let error = CustomErrorFactory.getError(CustomErrors, 'BirdMissingFirstMarking', [mappedProperty, event.metadata.primaryMark])
              birdEventValidationErrors = AddErrorToParent(error, birdEventValidationErrors, ref.record, ref.recordProp);
            }
            else {
              // -------------------------------------
              console.info('Bird exists, and no duplicate first-marking or missing first-marking');
            }

            // 2) A birds timeline must start with a first marking event (i.e. a first marking can't be after any other bird event)
            if (event.event.event_type === 'FIRST_MARKING_IN_HAND') {
              console.log('First marking event - checking for violation where bird records dated before this record');
              let violatingEventSearch = beforeEventList.find(beforeEvent => IsBirdEvent(beforeEvent.event_type));
              if (typeof violatingEventSearch !== 'undefined') {
                let ref = {
                  record: event.metadata.eventIndex,
                  recordProp: mappingSchema.col_mapping['event_type']
                }
                let errorProperty = 'event_type';
                let mappedProperty = mappingSchema.properties[errorProperty] || mappingSchema.backTranslationProperties[errorProperty] || errorProperty;

                let error = CustomErrorFactory.getError(CustomErrors, 'InvalidBirdTimeline', [mappedProperty, event.event.event_type, ref.record, event.metadata.primaryMark, violatingEventSearch.id])
                birdEventValidationErrors = AddErrorToParent(error, birdEventValidationErrors, ref.record, ref.recordProp);
                }
            }
            else if (event.event.event_type !== 'FIRST_MARKING_IN_HAND') {
              console.log('Not a first marking event for this bird - checking for violation where this record is dated earlier than the bird\'s first marking');
              let violatingEventSearch = afterEventList.find(afterEvent => afterEvent.event_type === 'FIRST_MARKING_IN_HAND');
              if (typeof violatingEventSearch !== 'undefined') {
                let ref = {
                  record: event.metadata.eventIndex,
                  recordProp: mappingSchema.col_mapping['event_type']
                }
                let errorProperty = 'event_type';
                let mappedProperty = mappingSchema.properties[errorProperty] || mappingSchema.backTranslationProperties[errorProperty] || errorProperty;

                let error = CustomErrorFactory.getError(CustomErrors, 'InvalidBirdTimeline', [mappedProperty, event.event.event_type, ref.record, event.metadata.primaryMark, violatingEventSearch.id])
                birdEventValidationErrors = AddErrorToParent(error, birdEventValidationErrors, ref.record, ref.recordProp);
                }
            }
          
          }
          else {
            // Need to also catch the case without an existing bird but in-hand events come in before first-marking
            if (event.event.event_type !== 'FIRST_MARKING_IN_HAND') {
              console.info('In-hand event for new bird, no first marking exists...');
              let ref = {
                record: event.metadata.eventIndex,
                recordProp: mappingSchema.col_mapping['event_type']
              }
              let errorProperty = 'event_type';
              let mappedProperty = mappingSchema.properties[errorProperty] || mappingSchema.backTranslationProperties[errorProperty] || errorProperty;

              let error = CustomErrorFactory.getError(CustomErrors, 'BirdMissingFirstMarking', [mappedProperty, event.metadata.primaryMark])
              birdEventValidationErrors = AddErrorToParent(error, birdEventValidationErrors, ref.record, ref.recordProp);
            }
            console.info('Bird does not exist - creating new bird as part of this record');
          }

          // 2) For in-hand events, validate that capture type is provided where event_bird_situation is NOT release site or captivity
          if (BBSSHelpers.IsInHandEvent(event.event.event_type)) {
            console.log('Validating in-hand event...')
            if (['WILD', 'SOURCE_SITE'].includes(event.event.event_bird_situation) && !event.event.event_capture_type) {
              let ref = {
                record: event.metadata.eventIndex,
                recordProp: mappingSchema.col_mapping['event_capture_type']
              };
              let errorProperty = 'event_capture_type';
              let mappedProperty = mappingSchema.properties[errorProperty] || mappingSchema.backTranslationProperties[errorProperty] || errorProperty;
              
              let error = CustomErrorFactory.getError(CustomErrors, 'MissingEventCaptureTypeError', [mappedProperty, event.event.event_type, ref.record, event.metadata.primaryMark])
              birdEventValidationErrors = AddErrorToParent(error, birdEventValidationErrors, ref.record, ref.recordProp);
            }
          }

          // 3) For a bird event, either a lat/long pair or northing/easting/coord-sys combination are required
          if (
            (typeof event.event.latitude === 'undefined' || !event.event.latitude || typeof event.event.longitude === 'undefined' || !event.event.longitude)
            && (typeof event.event.user_northing == 'undefined' || !event.event.user_northing || typeof event.event.user_easting == 'undefined' || !event.event.user_easting || typeof event.event.user_coordinate_system == 'undefined' || !event.event.user_coordinate_system)
          ) {
            let ref = {
              record: event.metadata.eventIndex,
              recordProp: mappingSchema.col_mapping['latitude']
            };
            let errorProperties = [
              'latitude', 'longitude', 'user_northing', 'user_easting', 'user_coordinate_system'
            ];
            let mappedProperties = errorProperties.map(errorProp => mappingSchema.properties[errorProp] || mappingSchema.backTranslationProperties[errorProp] || errorProp).join(', ');

            let error = CustomErrorFactory.getError(CustomErrors, 'MissingLocationDataError', [mappedProperties, event.event.event_type, ref.record, event.metadata.primaryMark]);
            birdEventValidationErrors = AddErrorToParent(error, birdEventValidationErrors, ref.record, ref.recordProp);
          }

        }
      });
      resolve(birdEventValidationErrors);
    }
    catch (error) {
      reject(error);
    }
  });
}

const BirdSubBirdValidation = (CustomErrors, eventBatch, lookupData, mappingSchema, businessErrors) => {
  // ----------------------------------------------------
  return new Promise((resolve, reject) => {
    
    console.info("BBBusinessValidationAndErrors.BirdSubBirdValidation()");
  
    let birdSubBirdValidationErrors = businessErrors;

    try {

      eventBatch.events.forEach(event => {
        // ------------------------------------------------------
        // If the event is a bird event, complete bird -> bird sub-object validation
        if (BBSSHelpers.IsBirdEvent(event.event.event_type)) {
          // ----------------------------------------------------------
          // Bird -> Bird Subobject Validations
          // 1) If a bird exists in the system then the species definition should match the existing definition
          if(!('species_id' in event.bird)) {
            console.log('Species definition code not interpreted');
            let ref = {
              record: event.metadata.eventIndex,
              recordProp: mappingSchema.col_mapping['species_code']
            }
            let errorProperty = 'species_code';
            let mappedProperty = mappingSchema.properties[errorProperty] || mappingSchema.backTranslationProperties[errorProperty] || errorProperty;

            let error = CustomErrorFactory.getError(CustomErrors, 'InvalidBirdSpeciesDefinition', [mappedProperty, ref.record, event.metadata.primaryMark])
            birdSubBirdValidationErrors = AddErrorToParent(error, birdSubBirdValidationErrors, ref.record, ref.recordProp);
          }

          // 2) If DOC stock involved in a record, the band size should be valid for the species
          if(event.mark_state.length > 0 && typeof event.bird.valid_band_prefixes !== 'undefined' && event.bird.valid_band_prefixes) {
            let markSplit = event.metadata.primaryMark.split('-');
            let bandPrefix = markSplit[0];
            let validBandPrefixes = event.bird.valid_band_prefixes;

            if(!validBandPrefixes.includes(bandPrefix)) {
              let ref = {
                record: event.metadata.eventIndex,
                recordProp: mappingSchema.col_mapping['prefix_number']
              }
              let errorProperty = 'prefix_number';
              let mappedProperty = mappingSchema.properties[errorProperty] || mappingSchema.backTranslationProperties[errorProperty] || errorProperty;

              let error = CustomErrorFactory.getError(CustomErrors, 'UnexpectedBandPrefixSizeWarning', [mappedProperty, ref.record, event.metadata.primaryMark.split('-')[0], event.bird.valid_band_prefixes]);
              birdSubBirdValidationErrors = AddErrorToParent(error, birdSubBirdValidationErrors, ref.record, ref.recordProp);
              }
          }

          // 3) If a bird exists in the system, then the species definition should match the existing definition
          // Assume spreadsheet only error at this point (client data entry validation in place to pull bird species information directly into record)
          if (typeof event.bird.id !== 'undefined' && event.bird.id) {
            let lookupBird = lookupData.birds.find(lookupBird => lookupBird.id === event.bird.id);
            let lookupBirdSpeciesDefinition = lookupBird.species;
            console.log(`Bird found and species definition: ${lookupBirdSpeciesDefinition}`);

            if (typeof event.bird.raw_species_code_nznbbs !== 'undefined' && lookupBirdSpeciesDefinition.species_code_nznbbs !== event.bird.raw_species_code_nznbbs) {
              let ref = {
                record: event.metadata.eventIndex,
                recordProp: mappingSchema.col_mapping['species_code']
              }
              let errorProperty = 'species_code';
              let mappedProperty = mappingSchema.properties[errorProperty] || mappingSchema.backTranslationProperties[errorProperty] || errorProperty;
              
              let error = CustomErrorFactory.getError(CustomErrors, 'SpeciesCodeMismatchWarning', [mappedProperty, ref.record, event.bird.raw_species_code_nznbbs, event.bird.raw_species_scientific_name, event.bird.raw_species_common_name, lookupBirdSpeciesDefinition.species_code_nznbbs, lookupBirdSpeciesDefinition.scientific_name_nznbbs, lookupBirdSpeciesDefinition.common_name_nznbbs])
              birdSubBirdValidationErrors = AddErrorToParent(error, birdSubBirdValidationErrors, ref.record, ref.recordProp);
            }
          }

          // 4) If a bird id join cannot be made in the system because there are multiple birds,
          //  prompt for this to be corrected in the system.
          if (typeof event.bird.raw_lookup_birds !== 'undefined' && event.bird.raw_lookup_birds) {
            console.log(`Multiple bird joins possible, error in lookup data: ${event.bird.raw_lookup_birds}`);
            let ref = {
              record: event.metadata.eventIndex,
              recordProp: mappingSchema.col_mapping['prefix_number']
            }
            let errorProperty = 'prefix_number';
            let mappedProperty = mappingSchema.properties[errorProperty] || mappingSchema.backTranslationProperties[errorProperty] || errorProperty;

            let error = CustomErrorFactory.getError(CustomErrors, 'BirdLookupError', [mappedProperty, event.metadata.primaryMark, ref.record, event.bird.raw_lookup_birds])
            birdSubBirdValidationErrors = AddErrorToParent(error, birdSubBirdValidationErrors, ref.record, ref.recordProp);
          }
        }
      });
      resolve(birdSubBirdValidationErrors);
    }
    catch(error) {
      reject(error);
    }
  });
}

const BirdProjectValidation = (CustomErrors, eventBatch, lookupData, mappingSchema, businessErrors) => {
  // ----------------------------------------------------
  return new Promise((resolve, reject) => {
    
    console.info("BBBusinessValidationAndErrors.BirdProjectValidation()");
  
    let birdProjectValidationErrors = businessErrors;

    try {

      eventBatch.events.forEach(event => {
        // ------------------------------------------------------
        // If the event is a bird event, complete bird -> bird sub-object validation
        if (BBSSHelpers.IsBirdEvent(event.event.event_type)) {
          // ----------------------------------------------------------
          // Project -> Bird Event, Project Validations
          let projectBanderMembership = lookupData.project[0].project_bander_membership.map(bander => bander.bander_id);

          // 1) The event_provider (L3) for a given bird event should be a member of the project for which bird events are recorded
          if (!projectBanderMembership.includes(event.event.event_provider_id)) {
            let ref = {
              record: event.metadata.eventIndex,
              recordProp: mappingSchema.col_mapping['event_provider_number']
            }
            let errorProperty = 'event_provider_number';
            let mappedProperty = mappingSchema.properties[errorProperty] || mappingSchema.backTranslationProperties[errorProperty] || errorProperty;

            let error = CustomErrorFactory.getError(CustomErrors, 'ProjectMembershipWarning', [mappedProperty, ref.record, lookupData.project[0].name])
            birdProjectValidationErrors = AddErrorToParent(error, birdProjectValidationErrors, ref.record, ref.recordProp);
          }

          // 2) The event_reporter (bander) for a given bird mark/record should be a member oft he project for which bird events are recorded
          if (!projectBanderMembership.includes(event.event.event_reporter_id)) {
            let ref = {
              record: event.metadata.eventIndex,
              recordProp: mappingSchema.col_mapping['event_reporter_number']
            }
            let errorProperty = 'event_reporter_number';
            let mappedProperty = mappingSchema.properties[errorProperty] || mappingSchema.backTranslationProperties[errorProperty] || errorProperty;

            let error = CustomErrorFactory.getError(CustomErrors, 'ProjectMembershipWarning', [mappedProperty, ref.record, lookupData.project[0].name])
            birdProjectValidationErrors = AddErrorToParent(error, birdProjectValidationErrors, ref.record, ref.recordProp);
          }
        }
      });
      resolve(birdProjectValidationErrors);
    }
    catch(error) {
      reject(error);
    }
  });
}

const BirdMarkValidation = (CustomErrors, eventBatch, lookupData, mappingSchema, businessErrors) => {
  // ----------------------------------------------------
  return new Promise((resolve, reject) => {
    
    console.info("BBBusinessValidationAndErrors.BirdMarkValidation()");
  
    let birdMarkValidationErrors = businessErrors;

    try {

      eventBatch.events.forEach(event => {
        // ------------------------------------------------------
        // If the event is a bird event, complete bird -> bird sub-object validation
        if (BBSSHelpers.IsBirdEvent(event.event.event_type)) {
          // ----------------------------------------------------------
          // Mark -> Bird Event, Mark Validations
          // 1) All bird events must have at least 1 mark in the mark configuration (i.e. the primary mark at least...)
          //    -> Anything out of this scope is not dealing with 'birdbanding' and therefore should probably be handled by another module of this system
          if (typeof event.mark_configuration === 'undefined' || !event.mark_configuration || event.mark_configuration.length < 1) {
            let ref = {
              record: event.metadata.eventIndex,
              recordProp: mappingSchema.col_mapping['prefix_number']
            }
            let errorProperty = 'prefix_number';
            let mappedProperty = mappingSchema.properties[errorProperty] || mappingSchema.backTranslationProperties[errorProperty] || errorProperty;

            let error = CustomErrorFactory.getError(CustomErrors, 'MissingMarkConfigurationError', [mappedProperty, ref.record])
            birdMarkValidationErrors = AddErrorToParent(error, birdMarkValidationErrors, ref.record, ref.recordProp);
          }
        }
      });
      resolve(birdMarkValidationErrors);
    }
    catch(error) {
      reject(error);
    }
  });
}

const BirdCharacteristicValidation = (CustomErrors, eventBatch, lookupData, mappingSchema, businessErrors) => {
  // ----------------------------------------------------
  return new Promise((resolve, reject) => {

    console.info("BBBusinessValidationAndErrors.BirdCharacteristicValidation()");

    let birdCharacteristicValidationErrors = businessErrors;

    try {
      eventBatch.events.forEach(event => {
        // ------------------------------------------------------
        // If the event is a bird event, complete bird -> bird sub-object validation
        if (BBSSHelpers.IsBirdEvent(event.event.event_type)) {
          // ----------------------------------------------------------
          // Characteristic -> Bird Event, Characteristic Validations
          // 1) Validate whether any characteristics remain 'raw' -> this indicates that they can't be interpreted
          event.characteristic_measurements.forEach((characteristicMeasurement, index) => {
            if ('raw_characteristic_name' in characteristicMeasurement) {
              let ref = {
                record: event.metadata.eventIndex,
                recordProp: mappingSchema.col_mapping[`characteristic_detail_${index + 1}`]
              }
              let errorProperty = `characteristic_detail_${index + 1}`;
              let mappedProperty = mappingSchema.properties[errorProperty] || mappingSchema.backTranslationProperties[errorProperty] || errorProperty;
              
              let error = CustomErrorFactory.getError(CustomErrors, 'UnknownCharacteristicError', [mappedProperty, ref.record]); 
              birdCharacteristicValidationErrors = AddErrorToParent(error, birdCharacteristicValidationErrors, ref.record, ref.recordProp);
            }
          });

          // 2) A bird status code must be valid (i.e. not alive after death or vice versa)
          let inStatusCode = event.characteristic_measurements.find(characteristicMeasurement => [41].includes(characteristicMeasurement.characteristic_id));
          let outStatusCode = event.characteristic_measurements.find(characteristicMeasurement => [43].includes(characteristicMeasurement.characteristic_id));
          // If both are provided -> validate against eachother
          if (typeof inStatusCode !== 'undefined' && inStatusCode && typeof outStatusCode !== 'undefined' && outStatusCode) {
            // If in status code is dead, out status code cannot be dead!
            switch (inStatusCode.value) {
              case 'dead: unspecified':
              case 'dead: recent':
              case 'dead: not recent': {
                if (outStatusCode.value === 'alive') {
                  let ref = {
                    record: event.metadata.eventIndex,
                    recordProp: mappingSchema.col_mapping['in_characteristic_status_code']
                  }
                  let errorProperties = ['in_characteristic_status_code', 'out_characteristic_status_code'];
                  let mappedProperties = errorProperties.map(errorProp => mappingSchema.properties[errorProp] || mappingSchema.backTranslationProperties[errorProp] || errorProp).join(' and ');

                  let error = CustomErrorFactory.getError(CustomErrors, 'InvalidStatusCode', [mappedProperties, ref.record, 'are', `eachother: ${inStatusCode.value} before ${outStatusCode.value}`, 'they are compatible'])
                  birdCharacteristicValidationErrors = AddErrorToParent(error, birdCharacteristicValidationErrors, ref.record, ref.recordProp);
                }
                break;
              }
              case 'alive':
              case 'unknown: bandonly':
              default:
                break;
            }
          }

          // If there is an existing bird, validate that the status code history is not violated
          if (typeof event.bird.id !== 'undefined' && event.bird.id) {
            // -----------------------------------------------------------
            let invalidBeforeCodes = {
              'alive': ['dead: unspecified', 'dead: recent', 'dead: not recent', 'unknown: bandonly'],
              'dead: unspecified': ['unknown: bandonly'],
              'dead: recent': ['unknown: bandonly'],
              'dead: not recent': ['unknown: bandonly'],
              'unknown: bandonly': []
            };
            let invalidAfterCodes = {
              'alive': [],
              'dead: unspecified': ['alive'],
              'dead: recent': ['alive'],
              'dead: not recent': ['alive'],
              'unknown: bandonly': ['alive', 'dead: unspecified', 'dead: recent', 'dead: not recent'],
            };

            let lookupBird = lookupData.birds.find(bird => bird.id === event.bird.id);
            
            let lookupBirdEventsBefore = lookupBird.event.filter(lookupEvent =>
              Moment(lookupEvent.event_timestamp).isBefore(Moment(event.event.event_timestamp))
            );

            let lookupBirdStatusCodesBefore = lookupBirdEventsBefore.map(lookupEventBefore => {
              return lookupEventBefore.characteristic_measurement.filter(lookupCharacteristic => {
                return [41, 43].includes(lookupCharacteristic.characteristic_id);
              });
            });
            lookupBirdStatusCodesBefore = [].concat.apply([], lookupBirdStatusCodesBefore);

            let lookupBirdEventsAfter = lookupBird.event.filter(lookupEvent =>
              Moment(lookupEvent.event_timestamp).isAfter(Moment(event.event.event_timestamp))
            );

            let lookupBirdStatusCodesAfter = lookupBirdEventsAfter.map(lookupEventAfter => {
              return lookupEventAfter.characteristic_measurement.filter(lookupCharacteristic => {
                return [41, 43].includes(lookupCharacteristic.characteristic_id);
              });
            });
            lookupBirdStatusCodesAfter = [].concat.apply([], lookupBirdStatusCodesAfter);

            // ** In Status Code **
            if (typeof inStatusCode !== 'undefined' && inStatusCode) {
              // Check lookup status codes before
              let invalidStatusCodeBefore = lookupBirdStatusCodesBefore.find(lookupStatusCode => {
                return invalidBeforeCodes[inStatusCode.value].includes(lookupStatusCode);
              });

              if (typeof invalidStatusCodeBefore !== 'undefined') {
                console.log('Invalid Status Code found before');
                let ref = {
                  record: event.metadata.eventIndex,
                  recordProp: mappingSchema.col_mapping['in_characteristic_status_code']
                }
                let errorProperty = 'in_characteristic_status_code';
                let mappedProperty = mappingSchema.properties[errorProperty] || mappingSchema.backTranslationProperties[errorProperty] || errorProperty;

                let error = CustomErrorFactory.getError(CustomErrors, 'InvalidStatusCode', [mappedProperty, ref.record, 'is', `other records before it for this bird in the application`, 'it is compatible with the bird\'s history recorded in the application']);
                birdCharacteristicValidationErrors = AddErrorToParent(error, birdCharacteristicValidationErrors, ref.record, ref.recordProp);
              }

              // Check lookup status codes after
              let invalidStatusCodeAfter = lookupBirdStatusCodesAfter.find(lookupStatusCode => {
                return invalidAfterCodes[inStatusCode.value].includes(lookupStatusCode);
              });

              if (typeof invalidStatusCodeAfter !== 'undefined') {
                console.log('Invalid Status Code found after');
                let ref = {
                  record: event.metadata.eventIndex,
                  recordProp: mappingSchema.col_mapping['in_characteristic_status_code']
                }
                let errorProperty = 'in_characteristic_status_code';
                let mappedProperty = mappingSchema.properties[errorProperty] || mappingSchema.backTranslationProperties[errorProperty] || errorProperty;

                let error = CustomErrorFactory.getError(CustomErrors, 'InvalidStatusCode', [mappedProperty, ref.record, 'is', `other records after it for this bird in the application`, 'it is compatible with the bird\'s history recorded in the application']);
                birdCharacteristicValidationErrors = AddErrorToParent(error, birdCharacteristicValidationErrors, ref.record, ref.recordProp);
              }
            }
  
            if (typeof outStatusCode !== 'undefined' && outStatusCode) {
              // Check lookup status codes before
              let invalidStatusCodeBefore = lookupBirdStatusCodesBefore.find(lookupStatusCode => {
                return invalidBeforeCodes[outStatusCode.value].includes(lookupStatusCode);
              });

              if (typeof invalidStatusCodeBefore !== 'undefined') {
                console.log('Invalid Status Code found before');
                let ref = {
                  record: event.metadata.eventIndex,
                  recordProp: mappingSchema.col_mapping['out_characteristic_status_code']
                }
                let errorProperty = 'out_characteristic_status_code';
                let mappedProperty = mappingSchema.properties[errorProperty] || mappingSchema.backTranslationProperties[errorProperty] || errorProperty;

                let error = CustomErrorFactory.getError(CustomErrors, 'InvalidStatusCode', [mappedProperty, ref.record, 'is', 'other records before it for this bird in the application', 'it is compatible with the bird\'s history recorded in the application'])
                birdCharacteristicValidationErrors = AddErrorToParent(error, birdCharacteristicValidationErrors, ref.record, ref.recordProp);
              }

              // Check lookup status codes after
              let invalidStatusCodeAfter = lookupBirdStatusCodesAfter.find(lookupStatusCode => {
                return invalidAfterCodes[outStatusCode.value].includes(lookupStatusCode);
              });

              if (typeof invalidStatusCodeAfter !== 'undefined') {
                console.log('Invalid Status Code found after');
                let ref = {
                  record: event.metadata.eventIndex,
                  recordProp: mappingSchema.col_mapping['out_characteristic_status_code']
                }
                let errorProperty = 'out_characteristic_status_code';
                let mappedProperty = mappingSchema.properties[errorProperty] || mappingSchema.backTranslationProperties[errorProperty] || errorProperty;

                let error = CustomErrorFactory.getError(CustomErrors, 'InvalidStatuCode', [mappedProperty, ref.record, 'is', 'other records after it for this bird in the application', 'it is compatible with the bird\'s history recorded in the application']);
                birdCharacteristicValidationErrors = AddErrorToParent(error, birdCharacteristicValidationErrors, ref.record, ref.recordProp);
              }
            }

            // -----------------------------
            // 3) Provide a warning if the birds sex changes with time
            let birdSex = event.characteristic_measurements.find(characteristicMeasurement => characteristicMeasurement.characteristic_id === 40);
            // Check if a sexing has been done and whether there is any uncertainty
            if (typeof birdSex  !== 'undefined' && typeof birdSex.value !== 'undefined' && birdSex.value && !birdSex.value.split('').includes('U')) {
              // ----------------------------------
              let lookupBirdEvents = lookupBird.event;
              let lookupBirdSexHistory = lookupBirdEvents.map(lookupBirdEvent => {
                return lookupBirdEvent.characteristic_measurement.filter(lookupCharacteristicMeasurement => {
                  return lookupCharacteristicMeasurement.characteristic_id === 40;
                });
              });
              lookupBirdSexHistory = [].concat.apply([], lookupBirdSexHistory);

              let invalidBirdSexHistory = lookupBirdSexHistory.filter(lookupBirdSex => {
                return (lookupBirdSex.value !== birdSex.value && !lookupBirdSex.value.includes('U')); 
              });

              if (invalidBirdSexHistory.length > 0) {
                let ref = {
                  record: event.metadata.eventIndex,
                  recordProp: mappingSchema.col_mapping['characteristic_sex']
                }
                let errorProperty = 'characteristic_sex';
                let mappedProperty = mappingSchema.properties[errorProperty] || mappingSchema.backTranslationProperties[errorProperty] || errorProperty;

                let error = CustomErrorFactory.getError(CustomErrors, 'ChangingBirdSexWarning', [mappedProperty, ref.record, event.metadata.primaryMark]);
                ChangingBirdSexWarning(null, ref, null, event, mappingSchema);
                birdCharacteristicValidationErrors = AddErrorToParent(error, birdCharacteristicValidationErrors, ref.record, ref.recordProp);
              }
            }
          }
        }
      });
      resolve(birdCharacteristicValidationErrors);
    }
    catch (error) {
      reject(error);
    }
  });
}

// =============
// EXPORTS
// =============

module.exports = {
  // CONSTANTS
  MARK_STATE_TIMELINE_REQUIREMENTS,
  // CLASSES
  CustomError,
  CustomErrorFactory,
  // FUNCTIONS
  PostProcessIndividualSchemaError,
  getRequiredNestedPropertySpreadsheetReferences,
  getSpecificPropertySpreadsheetReferences,
  // ERROR FUNCTIONS
  // General
  AddErrorToParent,
  // Business - General
  DuplicateValidation,
  BanderCertificationValidation,
  MarkStateTimelineValidation,
  // Business - Stock
  StockEventValidation,
  // Business - Birds
  // Bird -> Event
  BirdEventValidation,
  // Bird -> Bird Subobject
  BirdSubBirdValidation,
  // Bird -> Project
  BirdProjectValidation,
  // Bird -> Mark
  BirdMarkValidation,
  // Bird -> Characteristic
  BirdCharacteristicValidation,
}